# 高阶函数-节流函数

```
var throttle = function ( fn, interval ) {
		var __self = fn, // 保存需要被延迟执行的函数引用
		timer, // 定时器
		firstTime = true; // 是否是第一次调用
		return function () {
			var args = arguments,
			__me = this;
			if ( firstTime ) { // 如果是第一次调用，不需延迟执行
				__self.apply(__me, args);
				return firstTime = false;
			}
			if ( timer ) { // 如果定时器还在，说明前一次延迟执行还没有完成
				return false;

			timer = setTimeout(function () { // 延迟一段时间执行
				clearTimeout(timer);
				timer = null;
				__self.apply(__me, args);
			}, interval || 500 );
		};
	};


	window.onresize = throttle(function(){
		console.log( 1 );
	}, 500 );
  ```

# 高阶函数-分时函数

例如：原先1秒钟创建1000个节点，改为每隔200毫秒创建8个节点

timeChunk函数接受3个参数，第一个参数是创建节点时需要用到的数据，第2个参数是封装了创建节点逻辑的函数，第3个参数表示每一批创建的节点数量

```
var timeChunk = function( ary, fn, count ){
		var obj,
		t;
		var len = ary.length;
		var start = function(){
			for ( var i = 0; i < Math.min( count || 1, ary.length ); i++ ){
				var obj = ary.shift();
				fn( obj );
			}
		};
		return function(){
			t = setInterval(function(){
			if ( ary.length === 0 ){ // 如果全部节点都已经被创建好
				return clearInterval( t );
			}
			start();
			}, 200 ); // 分批执行的时间间隔，也可以用参数的形式传入
		};
	};

	var ary = [];
	for ( var i = 1; i <= 1000; i++ ){
		ary.push( i );
	};
	var renderFriendList = timeChunk( ary, function( n ){
		var div = document.createElement( 'div' );
		div.innerHTML = n;
		document.body.appendChild( div );
	}, 8 );
	renderFriendList();
```

# 高阶函数-惰性载入函数

在函数中有一些分支判断，但是在第一次进入条件分支后，在函数内部会重写这个函数，重写之后的函数就是期望的addEvent函数，在下一次addEvent函数的时候，addEvent函数里不在存在条件分支语句

```
<html>
	<body>
		<div id="div1">点我绑定事件</div>
		<script>
			var addEvent = function( elem, type, handler ){
				if ( window.addEventListener ){
					addEvent = function( elem, type, handler ){
						elem.addEventListener( type, handler, false );
					}
				}else if ( window.attachEvent ){
					addEvent = function( elem, type, handler ){
						elem.attachEvent( 'on' + type, handler );
					}
				}
				addEvent( elem, type, handler );
			};

			var div = document.getElementById( 'div1' );
			addEvent( div, 'click', function(){
				alert (1);
			});
			addEvent( div, 'click', function(){
				alert (2);
			});
		</script>
	</body>
</html>
```



## 一步步实现发布—订阅模式
1.首先要指定好谁充当发布者
2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
3.最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数

# 发布－订阅模式的通用实现
```
var event = {
	clientList: [],
	listen: function( key, fn ){
		if ( !this.clientList[ key ] ){
			this.clientList[ key ] = [];
		}
			this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表
		},
		trigger: function(){
			var key = Array.prototype.shift.call( arguments ), // (1);
			fns = this.clientList[ key ];
			if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息
				return false;
			}
			for( var i = 0, fn; fn = fns[ i++ ]; ){
				fn.apply( this, arguments ); // (2) // arguments 是trigger 时带上的参数
			}
		}
	};

	var installEvent = function( obj ){
		for ( var i in event ){
			obj[ i ] = event[ i ];
		}
	};

        event.remove = function( key, fn ){
		var fns = this.clientList[ key ];
		if ( !fns ){ // 如果key 对应的消息没有被人订阅，则直接返回
			return false;
		}
		if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消key 对应消息的所有订阅
			fns && ( fns.length = 0 );
		}else{
			for ( var l = fns.length - 1; l >=0; l-- ){ // 反向遍历订阅的回调函数列表
				var _fn = fns[ l ];
				if ( _fn === fn ){
					fns.splice( l, 1 ); // 删除订阅者的回调函数
				}
			}
		}
	};

	//再来测试一番，我们给售楼处对象salesOffices 动态增加发布—订阅功能：
	var salesOffices = {};
	installEvent( salesOffices );
	salesOffices.listen( 'squareMeter88', function( price ){ // 小明订阅消息
		console.log( '价格= ' + price );
	});
	salesOffices.listen( 'squareMeter100', function( price ){ // 小红订阅消息
		console.log( '价格= ' + price );
	});
	salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000
	salesOffices.trigger( 'squareMeter100', 3000000 ); // 输出：3000000

        salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅
	salesOffices.trigger( 'squareMeter88', 2000000 ); // 输出：2000000
```

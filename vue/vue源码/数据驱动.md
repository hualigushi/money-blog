Vue.js ⼀个核⼼思想是数据驱动。所谓数据驱动，是指视图是由数据驱动⽣成的，我们对视图的修改，
不会直接操作 DOM，⽽是通过修改数据。

当交互复杂的时候，只关⼼数据的修改会让代码的逻辑变的⾮
常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，⽽不⽤碰触 DOM，这样
的代码⾮常利于维护。

# new Vue 发⽣了什么

new 关键字在
Javascript 语⾔中代表实例化是⼀个对象，⽽ Vue 实际上是⼀个类，类在 Javascript 中是⽤ Function
来实现的，来看⼀下源码，在 `src/core/instance/index.js` 中。
```
function Vue (options) {
if (process.env.NODE_ENV !== 'production' &&
!(this instanceof Vue)
) {
warn('Vue is a constructor and should be called with the `new` keyword')
}
this._init(options)
}
```
可以看到 Vue 只能通过 new 关键字初始化，然后会调⽤ `this._init` ⽅法， 该⽅法在
`src/core/instance/init.js` 中定义。

```
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    ....

    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
}
```
在初始化的最后，检测到如果有 el 属性，则调⽤ `vm.$mount` ⽅法挂载 vm ，挂载的⽬标就
是把模板渲染成最终的 DOM

Vue 初始化主要就⼲了⼏件事情，合并配置，初始化⽣命周期，初始化事件中⼼，初始化渲染，初始
化 data、props、computed、watcher 等等。

# Vue 实例挂载的实现

Vue 中我们是通过 `$mount` 实例⽅法去挂载 vm 的

`src/platform/web/entry-runtimewith-compiler.js`

```
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    ...
    
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  return mount.call(this, el, hydrating)
}
```

这段代码⾸先缓存了原型上的 `$mount` ⽅法，再重新定义该⽅法，

el 可是是字符串也可以是元素，字符串的话调用querySelector寻找元素

⾸先，它对 el 做了限制，Vue 不能挂载在 body 、 html 这样的根节点上。接下来的是很关键的逻辑 ——
如果没有定义 render ⽅法，则会把 el 或者 template 字符串转换成 render ⽅法。

在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render ⽅法，⽆论我们是⽤单⽂件
.vue ⽅式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render ⽅法，

那么这个过程是 Vue 的⼀个“在线编译”的过程，它是调⽤ compileToFunctions ⽅法实现的。

最后，调⽤原先原型上的 $mount ⽅法挂载。

原先原型上的 $mount ⽅法在 `src/platform/web/runtime/index.js` 中定义，之所以这么设计完全是为了复⽤，因为它是可以被 runtime only 版本的 Vue 直接使⽤的。

```
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```
`$mount` ⽅法⽀持传⼊ 2 个参数，第⼀个是 el ，它表⽰挂载的元素，可以是字符串，也可以是
DOM 对象，如果是字符串在浏览器环境下会调⽤ query ⽅法转换成 DOM 对象的。

第⼆个参数是和服务端渲染相关，在浏览器环境下我们不需要传第⼆个参数。

$mount ⽅法实际上会去调⽤ `mountComponent` ⽅法，这个⽅法定义在
`src/core/instance/lifecycle.js` ⽂件中：

```
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    
    ...
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */ 
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

首先缓存 el 

mountComponent 核⼼就是先调⽤ vm._render ⽅法先⽣成虚拟 Node，再
实例化⼀个渲染 Watcher ，在它的回调函数中会调⽤ updateComponent ⽅法，最终调⽤
vm._update 更新 DOM。

Watcher 在这⾥起到两个作⽤，⼀个是初始化的时候会执⾏回调函数，另⼀个是当 vm 实例中的监测的数据发⽣变化的时候执⾏回调函数

函数最后判断为根节点的时候设置 vm._isMounted 为 true ， 表⽰这个实例已经挂载了，同时执⾏
mounted 钩⼦函数。 这⾥注意 vm.$vnode 表⽰ Vue 实例的⽗虚拟 Node，所以它为 Null 则表⽰
当前是根 Vue 的实例。

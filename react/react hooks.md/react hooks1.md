# 什么是 Hooks

Hooks 是一个 React 函数组件内一类特殊的函数（通常以 “use” 开头，比如 “useState”），使开发者能够在函数组件里使用 state 和 life-cycles，以及使用自定义 hook 复用业务逻辑。

# 动机
原先的 React 拥有两种创建组件的方式：函数组件 和 类组件。

函数组件就是一个传入参数返回 React 元素的 JS 函数，它没有内部 state 和生命周期，是无状态函数式组件，通常作为没有复杂交互的纯展示组件。

类组件顾名思义就是用一个 ES6 的 class 来定义的组件，它拥有 state 和完善的生命周期。

日常开发中我们可能更多的会使用类组件，因为很多情况下都不可避免地要使用 state 和生命周期。然而当使用场景越来越复杂的情况下，类组件却暴露出一些问题：

### 在组件之间重用有状态逻辑很困难

在以往，如果想要复用一段逻辑（比如：在所有页面所有组件都需要获取当前用户的身份权限，以此做一些特殊处理时），通常会使用：1. 带有这段复用逻辑的 高阶组件 2. 带有这段复用逻辑的普通组件配合上 render props(渲染属性)。但这导致的问题就是当我们的应用规模变得越来越大的时候，一些无关 UI 的 wrapper 组件越来越多，React 组件树变得越来越臃肿（在 devtool 中可以甚至看到数十层 wrapper），使开发和调试的效率变得很低。

### 按生命周期方法划分逻辑将变得难以理解

每个生命周期方法通常包含一组不相关的逻辑。例如，组件可能在 componentDidMount 和 componentDidUpdate中执行一些数据获取。然而，相同的 componentDidMount 方法可能还包含一些不相关的逻辑，它们设置事件监听器，并在 componentWillUnmount 中执行清理。本应一起更改的相互关联的代码会被分离，完全不相关的代码最终会组合在一个方法中。这很容易引入错误和不一致，比如常常被遗忘的“取消订阅”和“取消轮询”等逻辑。

### 性能优化困难

相比于函数组件，类组件很难获得提前编译带来的好处，同时类不能很好地压缩，并且它们使得热更新加载变得片状和不可靠。


# 规则
1. Hooks 命名都以 “use” 开头
2. Hooks 只能在 React 函数式组件中或另一个自定义 Hooks 中调用
3. Hooks 只能在函数顶层调用，不能在循环、条件或嵌套函数中调用（因为 React 依赖于4调用 Hooks 的顺序，在条件语句中可能会打乱顺序）

# useEffect怎么解绑一些副作用

让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。

这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。

## 怎么跳过一些不必要的副作用函数

每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。

```
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句
```

当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。

useEffect 在视图更新之后才清理上一次的副作用。这么处理其实也是和 useEffect 的特性相契合的。

React 只会在浏览器绘制后运行 useEffect。所以 Effect 的清除同样被延迟了。上一次的 Effect 会在重新渲染后被清除。

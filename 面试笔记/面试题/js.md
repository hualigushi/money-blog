1. js基础类型

2. 如何判断Symbol类型

3. 什么是闭包，作用， 优缺点

4. 如何对闭包进行垃圾回收

5. 数组去重

6. 数组打平

7. 深浅拷贝原理和实现，  深拷贝，循环引用如何处理

8. let var const 区别

9. 作用域是指什么

10. CommonJS 中的 require/exports 和 ES6 中的 import/export 区别

    设计一个方法，让CommonJS导出的模块也能改变其内部变量
    
11. promise原理 优缺点 如何中断promise 在事件循环中的执行过程是怎样的

12. JS 异步解决方案的发展历程以及优缺点

13. async/await和promise性能差异

14. forEach for of 区别

15. event loop

16. 事件流

17. es6 class 的new实例和es5的new实例有什么区别

18. 为什么canvas的图片为什么有跨域问题

19. 从输入URL到看到页面发生的全过程

20. JS继承的方式，优缺点

21. this

22. svg和canvas各自的优缺点

23. canvas渲染较大画布的时候性能会较低,为什么？

24. 描述二叉树的几种遍历方式

25. 排序，原理是什么

26. mouseover和mouseenter的区别

27. 移动端的click事件行为与PC端有什么不同？如何屏蔽掉这个不同？

28. Event对象中，target和currentTarget的区别

29. 移动端的点击穿透，原理及解决方法？

30. 事件委托

31. nodejs的eventEmitter的实现

32. 函数式编程

33. 如何实现原型替换

34. 模块在同一个页面引入两次，会引起几次js渲染？为什么？

35. 如何统一管理promise的错误处理函数？

36. promise的resolve函数中最多能携带几个参数？

37. 普通函数和箭头函数的区别

38. new操作符干了什么

39. 前端如何实现图片剪裁

40. 如何判断是不是数组

41. null 和 undefined

42. 判断对象的数据类型

43. Koa 的中间件原理，介绍一下 compose 函数

44. 介绍 NodeJS 的 EventLoop 机制，process.nextTick() 的作用

45. NodeJS 是单线程还是多线程，都有哪些线程，JS 为什么是单线程的

46. CommonJS 的实现原理

47. NodeJS 中存在哪些流，怎么理解 pipe() 及其优点

48. require 的解析规则

49. 介绍一下负载均衡，NodeJS 的 cluster 和 child_process 是什么

50. 单例模式、原型模式、工厂模式、观察者模式、策略模式、代理模式   功能、代码实现、使用场景

51. Node.js 哪里应用到了发布/订阅模式

52. Events 监听函数的执行顺序是异步还是同步的？

53. 说几个 Events 模块的常用函数吧？

54. 模拟实现 Node.js 的核心模块 Events

55. 说几个 fs模块的常用函数？什么情况下使用 fs.open的方式读取文件？用 fs模块写一个大文件拷贝的例子(注意大文件)？

56. require 的运行机制和缓存策略你了解吗？

57. require 加载模块的是同步还是异步？谈谈你的理解

58. exports 和 module.exports 的区别是什么？

59. require 加载模块的时候加载的究竟是什么？

60. call apply bind 的使用和区别 

61. Proxy

62. 数组乱序

63. 数据检测方法

64. 自己实现symbol

65. 装箱 拆箱

66. 简单介绍前端模块化，amd，cmd，commonjs es6 的 module
67. commonjs 和 es6 的 module 哪个支持异步
68. async await 和 promise 的关系(sync await 是 promise 和 generator 函数组合的一个语法糖)

69. ts 的泛型是什么作用(泛型决定了一个类型在不同的场景下能够在每个场景下从始至终的保持类型一致)
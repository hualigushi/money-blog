1. 算法，一个树结构，有id和一个子节点数组，要求在所有子节点上增加一个属性为父节点的parentId

2. 手写一个JSONP(promise版的)

3. 算法，实现一个螺旋矩阵

4. 有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，[2,1,4,3],这个算法的时间复杂度是多少

5. 完成一个Dialog组件，说说你设计的思路？它应该有什么功能？

6. 假设我现在有5000个圆，完全绘制出来，点击某一个圆，该圆高亮，另外4999个圆设为半透明，分别说说用svg和canvas怎么实现？  
   刚刚说的canvas的点击事件，怎么样实现？假如不是圆，这些图形是正方形、长方形、规则图形、不规则图形呢。
   那假如我的图形可能有变形、放大、偏移、旋转的需求呢？你的这个isPointInSide怎么处理？
   那个这个canvas的点击事件，点击的时候怎么样快速的从这5000个圆中找到你点击的那个圆（不完全遍历5000个节点）？
   
7. 手写函数的防抖和节流

8. 手写实现promise  手写promise的all方法

9. 手写vue的mixin方法

10. 如何实现一个可设置过期时间的localStorage

11. 实现一个发布订阅系统，包括on、emit、off等等    实现事件系统 eventEmitter

12. 用JavaScript的异步实现sleep函数

13. 手写快排，时间复杂度，优化

    ```
    function quickSort(array) {
        const _quickSort = (arr, left, right) => {
            if (left >= right) {
                return
            }
            let o = left
            let start = left
            let end = right
            while (left < right) {
                while (arr[right] >= arr[o] && right > left) {
                    right--
                }
                while (arr[left] <= arr[o] && left < right) {
                    left++
                }
                if (left !== right) {
                    swap(arr, left, right)
                }
            }
            [arr[o],arr[left]] = [arr[left],arr[o]]
            _quickSort(arr, start, left - 1)
            _quickSort(arr, left + 1, end)
        }
        _quickSort(array, 0, array.length - 1)
    }
    ```

    

14. 手写冒泡

15. 手写实现jsonp

16. 设计一个单点登录的系统

17. 实现一个联想搜索组件

18. 有一个无序数组求中位数

19. 有一个数组和一个值，需要求大于等于该值的最小长度，例如[2, 3, 4, 7]和5，那么最小就是1，因为7大于5 如果数字是8，那么最小就是2, 因为4 + 7大于8

20. 有序数组中小于某个数的个数

21. 如何对请求进行缓存，例如有10个异步请求，如果有一个异步请求返回结果剩下的请求就用这个结果，并且能过传入成功和失败的回调函数

22. 实现(10).add(10).add(10)

23. 在从左向右和从上往下皆为升序的二维数组中，查找一个数是否存在，存在的话输出它的位置

24. 函数柯里化

25. 实现 ES6 的 class 语法

26. 图片懒加载

27. 洗牌算法

28. 实现一个deepClone需要兼容set、map、symbol、object,能成功克隆带有循环引用的对象

29. 用 Class 实现 EventEmitter，要求拥有 on，once，emit，off 方法

30. 实现 sum 函数
```
sum(1)(2)(3) == 6; // true
sum(1, 2, 3) == 6; // true
```
30. 用尾递归实现 fibonacci 数列
31. 代码实现中断 Promise 的运行
32. 实现以下功能，当对一个 arr 做 push 操作时，会自动打印一行提示消息
```
const arr = [1,2,3];
arr.push(4);
// arr pushed a new element: 4
```
33. 实现 co 函数
34. 有一组图片，实现后一张图片必须等到上一张图片加载完毕，才能开始加载
35. 为 Test 类添加方法，打印指定内容
```
class Test {
    constructor() {
        this.person = { name: "jack", age: 38, position: "CTO" };
    }
    // ......
}

const test = new Test();
for (const ele of test) {
    console.log(ele);
}
// [ 'name', 'jack' ]
// [ 'age', 38 ]
// [ 'position', 'CTO' ]
```
36. 实现 handler 函数，遇到 b 和 ac 都要去除
```
console.log(handler("aabaa")); // 'aaaa'
console.log(handler("abaccbc")); // 'c'
console.log(handler("aaccc")); // 'c'
console.log(handler("aaabccc")); // ''
```
37. 实现 decode 函数
`decode('HG[3|B[2|CA]]F') === 'HGBCACABCACABCACAF' // true`
38. 实现 _bind 函数，使打印 success
```
function Animal(name, color) {
  this.name = name;
  this.color = color;
}
Animal.prototype.say = function() {
  return `I'm a ${this.color} ${this.name}`;
};
const Cat = Animal._bind(null, "cat");
const cat = new Cat("white");
if (
  cat.say() === "I'm a white cat" &&
  cat instanceof Cat &&
  cat instanceof Animal
) {
  console.log("success");
}
```
39. CSS 实现圆环进度条效果
40. 给定任意非负整数，反复累加各位数字直到结果为个位数为止。例如给定非负整数912，第一次累加9+1+2 = 12, 第二次累加1+2 = 3, 3为个位数，循 环终止返回3
```
function add(num){
    if(isNaN(num)) return;
    if(num<10) return num
    const res=num.toString().split('').reduce((sum,value)=>{
        return sum+Number(value)
    },0)
    return add(res);
}
add(345);
3
```
41. add(1); // 1   add(1)(2);  // 3   add(1)(2)(3)；// 6
```
function add(a) {
    function sum(b) { // 使用闭包
        a = a + b; // 累加
        return sum;
     }
     sum.toString = function() { // 重写toString()方法
        return a;
    }
     return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)；// 6
```
44. 给定一个整数无序数组和变量 sum，如果存在数组中任意两项和使等于 sum 的值，则返回 true。否则,返回 false。例如，数组 [3,5,1,4]和 sum=9，函数应该返回 true，因为 4+5=9。

解决这个问题的一个很好的方法是遍历数组，创建 Set保存相对差值。

当我们遇到 3时，我们可以把 6加到 Set中, 因为我们知道我们需要找到 9的和。然后，每当我们接触到数组中的新值时，我们可以检查它是否在 Set 中。当遇到 5时，在 Set 加上4。最后，当我们最终遇到 4时，可以在 Set中找到它，就返回 true。
```
const findSum = (arr, val) => {  
  let searchValues = new Set();  
  searchValues.add(val - arr[0]);  
  for (let i = 1, length = arr.length; i < length; i++) {    
    let searchVal = val - arr[i];    
    if (searchValues.has(arr[i])) {      
      return true;    
    } else {      
      searchValues.add(searchVal);    
    }
    };  
  return false;
};
```
```
const findSum = (arr, sum) =>  arr.some((set => n => set.has(n) || !set.add(sum - n))(new Set));
```
因为 Set.prototype.has()的时间复杂度仅为 O(1)，所以使用 Set 来代替数组，最终使整个解决方案的线性运行时为 O(N)。

如果使用 Array.prototype.indexOf()或 Array.prototype.includes()，它们的时间复杂度都为 O(N)，则总运行时间将为 O(N²)，慢得多！

45. Node.js 中有一个queryString模块，可以实现将 urlStr 主机地址后面的参数转化为对象。

`let urlStr = 'http://www.inode.club?name=koala&study=js&study=node';`
转换结果如下:

`{ name: 'koala', study: [ 'js', 'node' ] }`
代码实现
```
let urlStr = 'http://www.inode.club?name=koala&study=js&study=node'
// 参数转成对象
function queryString(request){
    let params = request.split('?')[1];
    let param = params.split('&');
    let obj = {};
    for (let i = 0;i<param.length;i++){
        let paramsA = param[i].split('=');
        let key = paramsA[0];
        let value = paramsA[1];
        if(obj[key]){
            obj[key] = Array.isArray(obj[key])?obj[key]:[obj[key]];
            obj[key].push(value);
        }else{
            obj[key] = value;
        }
    }
    return obj;
}
console.log(queryString(urlStr));
```

46. 层次遍历一棵二叉树

47. 字符串中找出最长最多重复的子串

48. 无重复字符的最长子串

    ```
    var lengthOfLongestSubstring = function (s) {
        let obj = {} // 用于存储字符出现的位置
        let res = 0 // 位置
        let j = 0 // 不重复字符的index
    
        for (let i = 0; i < s.length; i++) {
            // 当前值是否在对象中存储过
            const value = obj[s[i]]
            if (value !== undefined) {
                // 更新上一次重复值的index
                // value + 1 跳过之前重复的字符
                // j : 之前不重复的index重复字符 需要全部跳过
                j = Math.max(value + 1, j)
            }
    
            // 每个字符都计算一下最长不重复值，保存最大值
            // 不重复最长长度 = 当前index - 上一次重复值的index + index 从0开始，长度从1开始
            res = Math.max(res, i - j + 1)
            obj[s[i]] = i
        }
    
        return res
    }
    
    
    
    var lengthOfLongestSubstring = function (s) {
        var i = 0, // 不重复字符的index
            res = 0 // 更新无重复字符的长度
        for (j = 0; j < s.length; j++) {
            // 查找：不重复字符-当前index之间 有没有出现当前字符
            let index = s.slice(i, j).indexOf(s[j])
            if (index === -1) {
                // 更新无重复字符 - 当前index之前 有没有出现当前字符
                res = Math.max(res, j - i + 1)
            } else {
                // 更新i = 不重复字符的index    
                // 不重复字符的index = 原不重复的字符index + i-j中出现重复字符的index + 跳过该重复字符
                i = i + index + 1
            }
        }
        return res
    }
    ```

49. 查找斐波纳契数列中第 N 个数

```
const fibonacci = (n) => {
    let arr = new Array(n).fill(0)
    arr[1] = 1
    for (let i=2;i<arr.length;i++) {
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[n-1]
}
```

50. 将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)

```
const reverseInteger = (n) => {
    if (n >= Math.pow(2, 31) - 1 || n <= Math.pow(-2, 31) + 1) {
        return 0
    }
    if (n < 0) {
        n = n.toString().split('-')[1]
        n = '-' + [...n].reverse().join('')
        n = +n
    } else {
        n = +[...n].reverse().join('')
    }
    return n
}

const reverseInteger = (n) => {
    if (n >= Math.pow(2, 31) - 1 || n <= Math.pow(-2, 31) + 1) {
        return 0
    }

    if (n === 0) {
        return 0
    }
    let res = 0
    while (n !== 0) {
        res = res * 10 + n % 10
        n = parseInt(n / 10)
    }
    return res
}
```

51. 数组交集差集并集

```
let one = [1, 2, 3, 4, 5];
let two = [2, 3, 4, 7];
const intersection = (a, b) => {
  // a b数组的交集
  let arr = a.filter(v => {
    // b是否包含a的元素，包含就返回true,交集
    return b.includes(v);
  });
  return arr;
};
const difference = (a, b) => {
  // a b 数组的差集
  let arr = [...a, ...b].filter(v => {
    // a和b是否包含v 不包含返回!false  出现有一个不包含(另一个数组就包含 找到差值),就返回true 添加进数组
    return !a.includes(v) || !b.includes(v);
  });
  return arr;
};

const unionArr = (a, b) => {
  return Array.from(new Set([...a, ...b])); // 并集可以理解为合并数组去重,直接用set即可
};
console.log(difference(one, two), intersection(one, two), unionArr(one, two));



function arrSet(a, b, type) {
  let set;
  a = new Set(a);
  b = new Set(b);
  if (type === 'difference') {
    // ab数组差集
    set = new Set([...a, ...b].filter(x => !b.has(x) || !a.has(x)));
  } else if (type === 'intersection') {
    // ab数组交集
    set = new Set([...a].filter(x => b.has(x)));
  } else {
    // ab数组并集
    set = new Set([...a, ...b]);
  }
  return Array.from(set); // 转为set
}
console.log(
  arrSet(one, two, 'difference'),
  arrSet(one, two, 'intersection'),
  arrSet(one, two, 'union')
);
```

52. 实现 promise.all 的 polyfill
53. 设计一个通过拖拽，然后交换位置的组件

54. 给定一个数组，请你按照升序 & 降序的规则去排列它

```
function bubble (arr, type) {
  function sortFn(a, b) {
     return type === 'up' ? a-b : b-a
  }
  return arr.sort(sortFn)
}
bubble([1, 4, 10, 2, 5, 18, 14], 'down')
```

55. 手写发布订阅

56. 手写数组乱序

57. 实现数组的 map 方法

```
Array.prototype.map = function() {    
// todo
}
解 思路是看如何使用通过如何使用来判断条件
Array.prototype.Map = function(fn){    
1.首先我们看到当前传进来到是一个方法    
2.map return 出去的是每个循环后的总数组    
3.如何获取值，值其实就是当前的this    
let arr = []    
let array = this    
for(let i=0,len=array.length;i<len;i++){        
	arr.push(fn(array[i]))    
}    
return arr}[1,2,3,5,5].Map(function(){})
```

58. 写一个函数将如下数组拍平并按从大到小排序

```
[5, [3, 1], [4, [6, 9]]]
// 扁平化 最快直接toString
let arr = [5, [3, 1], [4, [6, 9]]]
// 直接排序，但是值是一个string 所以我们进行number
arr.toString().split(',').sort((x,y)=>y-x).map(item=>Number(item))
```

59. 顺序执行每一个函数，后一个函数以前一个函数的执行结果为参数，并返回最后一个函数的执行结果；第二个括号的值作为参数传给第一个函数。

```
let result = compose(fn1, fn2, fn3)(1);
1.首先扔进来一堆方法
2.题目意思是首先return 一个方法出来不然最后的（）执行不了
3.最后的值要放到前面的方法里面所以前面的值需要保留需要闭包
4.前后都需要参数 reduce 比for 循环更好用
let compose = function(...arr){    
	let fnlist= arr    
	return function(val){        
		return fnlist.reduce((x,y)=>{            
			return y(x)        
		},val)    
	}
}
```

60. 算法：实现36进制转换

61. 实现原生ajax

62. 算法：树的遍历有几种方式，实现下层次遍历

63. 算法：判断对称二叉树

64. 算法题：合并乱序区间

65. 算法题：老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。 目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1， 最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能 让2个孩子满足。

66. 算法题：给定一个正整数数列a, 对于其每个区间, 我们都可以计算一个X值; X值的定义如下: 对于任意区间, 其X值等于区间内最小的那个数乘上区间内所有数和; 现在需要你找出数列a的所有区间中, X值最大的那个区间; 如数列a为: 3 1 6 4 5 2; 则X值最大的区间为6, 4, 5, X = 4 * (6+4+5) = 60;

67. 算法题：两个有序链表和并成一个有序链表

68. 查找一个字符串是否在另一个字符串中存在,考查KMP

69. 链表转置,迭代/递归

70. 合并两个有序链表

71. 合并两棵BST

72. 二叉树前/中/后序遍历

73. 二叉树深度优先/DFS,广度优先(层序遍历)/BFS

    ```
    // DFS借助栈
    function dfs(root){
        let stack = []
        if(!root){
            stack.push(root)
        }
        while(stack.length!==0){
            let node = stack.pop()
            console.log(node.value)
            if(node.right){
                stack.push(node.right)
            }
            if(node.left){
                stack.push(node.left)
            }
        }
    }
    
    // BFS借助队列
    function bfs(root){
        let queue = []
        if(!root){
            queue.push(root)
        }
        while(queue.length!==0){
            let node = queue.shift()
            console.log(node.value)
            if(node.left){
                stack.push(node.left)
            }
            if(node.right){
                stack.push(node.right)
            }
        }
    }
    ```

74. 给定一个链表，判断链表中是否有环，比如下图这种即为有环链表。

    ```
    const cycle1 = function (node) {
      let set = new Set()
      while (node) {
        if (set.has(node))
          return true
        else
          set.add(node)
        node = node.next
      }
      return false
    };
    
    
    
    const cycle2 = function (node) {
      let start = node
      let end = node.next
      while (start !== end) {
        // 没有环就null
        if (end === null || end.next === null) return false
        start = start.next
        end = end.next.next
      }
      return true
    }
    ```

75. 分析一个项目的依赖结构，并按依赖优先级排序。 已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：

- 每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载
- 每一个依赖不希望在钱多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：

```
ProjectA
- a@0.1.0
    - d@0.2.0
    - c@0.1.0
- b@0.1.1
    - e@0.1.2
    - c@0.1.2
- c@0.2.0
复制代码
```

则其中一种输出的依赖优先级排序为：
 `['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']`


```
const cycle1 = function (node) {
  let set = new Set()
  while (node) {
    if (set.has(node))
      return true
    else
      set.add(node)
    node = node.next
  }
  return false
};



const cycle2 = function (node) {
  let start = node
  let end = node.next
  while (start !== end) {
    // 没有环就null
    if (end === null || end.next === null) return false
    start = start.next
    end = end.next.next
  }
  return true
}
```

76. 请用 React 实现一个搜索框组件，功能包括：

- 输入文本字数限制

- 可配置输入文本约束，比如仅限输入数字

- 用户输入时可支持关键字搜索，并出现下拉框展示相关项

  ```
  import React, { Component } from 'react';
  import './input.css'
  
  function debounce(fn, delay = 500) {
    let timeout = null
    return function (e, ...args) {
      e.persist && e.persist()
      timeout && clearTimeout(timeout)
      timeout = setTimeout(() => {
        fn.call(this, e, ...args)
      }, delay)
    }
  }
  
  class Tips extends Component {
    render() {
      const { tipsList } = this.props
      return tipsList && tipsList.length !== 0 ? (
        <div className="tips__container">
          {tipsList.map((item, index) => {
            return (
              <a href="#" key={index} className="link">{item}</a>
            )
          })}
        </div>
      ) : <div></div>
    }
  }
  
  export default class Input extends Component {
    constructor(props) {
      super(props);
      this.state = {
        keyWords: [
          '前端工程师1', '前端高级开发1', '后端工程师1', '测试开发1', '项目主管1', 'dress', 'Recent', '123456', 'awdad1'
        ],
        inputValue: '',
        inputType: 'text',
        inputMaxLen: 20,
        wordsList: []
      }
      this.handleInput = debounce(this.handleInput, 200)
      this.handleMaxLenChange = debounce(this.handleMaxLenChange, 400)
    }
  
    handleInput = (e) => {
      const { target: { value } } = e
      const { keyWords } = this.state
      const tipsList = !value
        ? []
        : keyWords.filter(item => {
          const res = item.search(new RegExp(value, 'i'))
          return res !== -1
        })
      this.setState({
        inputValue: value,
        tipsList
      })
    }
  
    handleTypeClick = (e) => {
      const { target: { name } } = e
      this.setState({ inputType: name })
    }
  
    handleMaxLenChange = (e) => {
      const { target: { value } } = e
      const { inputValue } = this.state
      const newInputValue = inputValue.substr(0, +value)
      // 如果设置最大长度小于现在关键词的长度，则截取一下
      this.input.value = newInputValue
      this.setState({ inputMaxLen: value, inputValue: newInputValue })
    }
  
    render() {
      const { tipsList, inputType, inputMaxLen } = this.state
      return (
        <div className="container">
          <div className="control__container" onClick={this.handleTypeClick}>
            <button name="text">文本</button>
            <button name="number">数字</button>
            <span>最大长度: </span>
            <input type="number" placeholder="默认: 20" onInput={this.handleMaxLenChange} />
          </div>
          <div className="input__container">
            <div className="input__wrap">
              <input
                ref={input => this.input = input}
                placeholder="请输入关键词"
                type={inputType}
                maxLength={inputMaxLen}
                onInput={this.handleInput} />
              <button>搜索</button>
            </div>
            <Tips tipsList={tipsList} />
          </div>
        </div>
      )
    }
  }
  
  
  
  
  .container {
    width: 600px;
    height: 400px;
    margin: 0 auto;
    padding: 30px;
    background: #fff;
  }
  
  .input__container {
    margin-top: 30px;
  }
  
  .input__wrap {
    display: flex;
    align-items: center;
  }
  
  .input__wrap input {
    box-sizing: border-box;
    width: 85%;
    height: 50px;
    padding: 0 10px;
    border: #666 1px solid;
    border-right: 0;
    outline: none;
  }
  
  .input__wrap button {
    cursor: pointer;
    box-sizing: border-box;
    width: 15%;
    height: 50px;
    color: #fff;
    font-size: 20px;
    border: none;
    border: #666 1px solid;
    outline: none;
    background: #1890ff;
  }
  
  .control__container {
    display: flex;
    align-items: center;
  }
  
  .control__container button {
    cursor: pointer;
    width: 50px;
    height: 30px;
    margin-right: 10px;
    color: #fff;
    outline: none;
    border: #333 1px solid;
    border-radius: 8px;
    background: #1890ff;
  }
  
  .control__container span {
    margin-left: auto;
    margin-right: 10px;
    color: #666;
    font-size: 14px;
  }
  
  .tips__container {
    overflow-y: scroll;
    max-height: 200px;
    border: #333 1px solid;
    border-top: 0;
  }
  
  .tips__container .link {
    display: block;
    height: 30px;
    padding: 5px 10px;
    color: #666;
    line-height: 30px;
    text-decoration: none;
  }
  
  .tips__container .link:hover {
    color: #fff;
    background: #666;
  }
  
  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    display: none;
  }
  ```


77. 实现⼀个函数 reverse(a, n) ，反转⼀个含有 n 个整数的数组 a（直接在数组a上操作，元素交换次数 尽可能少，不能使⽤js Array 类内置属性和⽅法）

    ```
    function reverse(arr) {
      let len = arr.length
      for (let start = 0; start < Math.floor(len / 2); start++) {
        let end = len - start - 1;
        [arr[start], arr[end]] = [arr[end], arr[start]]
      }
      return arr
    }
    ```

    

78. 实现⼀个函数 countLongest(tree) ，输⼊⼀棵⼆叉树，返回⼆叉树中距离最⻓的两个叶⼦节点之间 的距离。

    ```
    var x = [0, 1, 2, 3]
    reverse(x, 4) // x = [3, 2, 1, 0]
    var y = [1, 2, 3, 4, 1]
    reverse(y, 5) // y = [1, 4, 3, 2, 1]
    var tree1 = {
      value: 1,
      left: {
        value: 2
      },
      right: {
        value: 3
      }
    }
    countLongest(tree1) // 2
    var tree2 = {
      value: 1,
      left: {
        value: 2,
        left: {
          value: 3,
          left: {
            value: 6
          }
        },
        right: {
          value: 4
        }
      },
      right: {
        value: 5
      }
    }
    countLongest(tree2) // 4
    ```

    

79. 在前端开发中，通常会把多个js⽂件合并成⼀个⽂件，以减少⽹络请求次数，达到优化加载速度的⽬ 的，但是当⽂件之间存在依赖关系时，对js合并的顺序，会有⼀定的要求，⽐如 A.js 依赖了 B.js，那打 包后的⽂件，B.js 需要排在 A.js 的前⾯。 实现⼀个函数 resolve(tree) ，根据js的依赖关系树 tree，输出合理的打包顺序的数组（结果可能不 唯⼀，输出其中⼀种即可）。

样例

```
var tree1 = {
  name: 'main.js',
  require: [{
    name: 'A.js'
  }, {
    name: 'B.js'
  }]
}
resolve(tree1) // ['A.js', 'B.js', 'main.js']
var tree2 = {
  name: 'page.js',
  require: [{
    name: 'A.js',
    require: [{
      name: 'B.js',
      require: [{
        name: 'C.js'
      }]
    }]
  }, {
    name: 'D.js',
    require: [{
      name: 'C.js'
    }, {
      name: 'E.js'
    }]
  }]
}
resolve(tree2) // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']
```

```
function countLongest(tree) {
  if (!tree) return 0
  let res = 0

  function dfs(node) {
    if (!node) return 0
    const leftMax = dfs(node.left)
    const rightMax = dfs(node.right)
    res = Math.max(leftMax + rightMax, res)
    return Math.max(leftMax, rightMax) + 1
  }
  dfs(tree)
  return res
}

console.log(countLongest({
  value: 1,
  left: {
    value: 2
  },
  right: {
    value: 3
  }
}))
console.log(countLongest({
  value: 1,
  left: {
    value: 2,
    left: {
      value: 3,
      left: {
        value: 6
      }
    },
    right: {
      value: 4
    }
  },
  right: {
    value: 5
  }
}))
```



80. 给定⼀个整数数组 a，实现⼀个函数 countMax(a) ，计算出从 a 中选择出多个不相邻元素组成最⼤的 和是多少。

样例

```
var x = [1, 4, 5, 3]
countMax(x) // 7
var y = [3, 12, 6, 2, 4]
countMax(y) // 16
```

```
function resolve(npmList) {
  const res = []

  function dfs(npmList) {
    if (npmList.length === 0) return

    npmList.forEach((npm) => {
      const { name, require = [] } = npm
      dfs(require)
      !res.includes(name) && res.push(name)
    })
    return
  }
  dfs(npmList)
  return res
}


console.log(resolve([{
  name: 'page.js',
  require: [{
    name: 'A.js',
    require: [{
      name: 'B.js',
      require: [{
        name: 'C.js'
      }]
    }]
  }, {
    name: 'D.js',
    require: [{
      name: 'C.js'
    }, {
      name: 'E.js'
    }]
  }]
}]))
```

81. 算法：判断数组中是否存在两个数相加等于目标值，给出多种思路与时间空间复杂度（暴力循环，排序后循环剪枝，动态规划）

82. 实现正则获取url params

83. 合并n个有序链表

84. 渲染一个超长的list，实现dom节点的复用

85. 实现正则切分千分位（10000 => 10,000）

86. 实现正则切分银行卡卡号（像实体卡一样四位一个空格）

87. 判断一个ipv4地址是否存在已有的1000万条ipv4地址中（bitmap）

88. 一次可以走一步或者两步，n个阶梯的楼梯有多少种走法

89. 实现扫雷（二维数组，随机分布地雷坐标）

90. 计算累进税率

91. 求一个数组中比左边和右边的元素都大的元素（On）

92. 实现双向绑定

93. 算法场景题：数型系统，包含字符串关键词，如何对其作出效率很好的搜索？（应该结合B树来说）

94. 编程题：请使用js函数写出markdown转html的文本编辑器

95. 算法题：在一个字符串中，找到最大不连续子字符串的长度。

96. 有这么一个功能场景，老师随机点名，上堂课没来的同学被抽到的概率会大幅增加，怎么去做？

97. 实现一个 difference 函数，输出两个数组中不同的部分
    [`1, 2, 3, 5, 4][2, 4, 7] => [1, 3, 5, 7]`
    
98. 给定一个 words 数组，其中可能有重复的单词，输出其中不重复的单词的个数，以及每个单词出现的次数
    (去重 + 计数)
    
99. 实现一个布局，使得图片无论在什么情况下都是居中显示
    当图片大小超出屏幕大小，按照比例收缩
    
100. 写一个编程题

     ```
     let x = {
       a: {
         b: {
           c: 1
         }
       }
     }
     let y = 'a.b.c'
     
     function fun(obj, str) {}
     
     console.log(`fun(x,y):`, fun(x, y)) // 1
     复制代码
     ```

     实现一个 fun 方法完成输出(考虑边界和优化()
     
101. 给你一个数字N(1<=N<=1e9)，代表集合中有N个人，现在每次选若干个人出来，然后把这若干个人里面其中一个置为队长，这便是一种不同的选法，问你总共有多少种选法？ 

       解法: 组合数学+快速幂 

       ans = C(n,1)*1 + C(n,2)*2 + ... + C(n,n) = n*2^(n-1)

102. 给一个迷宫(1<=N,M<=500), 小明要从初始位置S到达目标位置T，支持五种操作，上/下/左/右/瞬移，瞬移一共可以用5次，每次可以从 (x,y) 移动到 (n+1-x, m+1-y)， 问小明从S到T的最短时间，如果不能到达输出-1。 

       解法: 搜索题，定义状态 vis[x][y][z] 代表小明到达 (x,y)位置共使用了z次瞬移，对五种状态进行转移即可。

103. **有一个长度未知的数组a，如果它的长度为0就把数字1添加到数组里面，否则按照先进先出的队列规则让第一个元素出队。**

     分析：这道题主要是考核了数组的队列方法和栈方法。另外，原题还有字数限制的，只有在字数小于30并且结果正确时才可以满分。所以，我们可以使用三目运算符（： ？）来减少字数。代码如下：

     `a.length === 0  ? a.push(1) : a.shift()`

104. 请把第1行第2行...（ul之间有10个li元素）插入body里面，注意：需要考虑到性能问题。

105. 不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标

     ```
     // 错误！！！！
     // JavaScript数组是稀疏数组，比如，通过new Array(100)创建一个新的数组的，虽然他的长度是100，但是实际上他是一个空数组，也就是说没有真实存在的元素。所以使用map方法，根本不会去遍历这个数组100次的
     var a= new Array(100)
     a = a.map((item, index) => {
     	return index
     })
     // 正确
     var a = Array(100).join(',').split(',').map((item, index) => {
     	return index
     })
     ```

     

106. 请写个正则表达式匹配所有二级域名是9game.cn和其目录下的网址，比如：http://abc.9game.cn/sname/view/

107. 有一个长度为100的数组，请以优雅的方式求出该数组的前10个元素之和

     ```
     var a = [1,2,3,4,5,6,7,8,9,10,12,13,14],
     sum = 0
     
     sum = a.slice(0, 10).reduce((acc, cur) => {
     	return acc + cur
     }, 0)
     console.log(sum)
     ```

     

108. 实现对数组进行乱序

```
var a = [1,2,3,4,5,6,7,8,9,10,12,13,14],
sign = 0
var b = a.sort((a, b) => {
	sign = (Math.random() > 0.5) ? 1 : -1
	return (a-b)*sign
})
console.log(b)
```

109. 老鼠喝奶问题
      n瓶牛奶，其中只有1瓶有问题。有问题的牛奶会导致老鼠喝了第二天死掉。 如何用最少的老鼠测试出哪瓶牛奶有问题。

回答说：每个老鼠喝一批，比如a老鼠喝1-2瓶，b老鼠喝2-3瓶。依次类推。可用n-m只老鼠测试出来。他说有更优的方案。然后我就没想出来。。

其实需要解决的问题是：
 1.如何让一个老鼠尽可能表示更多牛奶的状态？
 2.又如何使得每一种老鼠们的状态组合都能唯一确定一瓶牛奶的状态？

这里的牛奶状态指的是 有毒 和 无毒。老鼠状态指的是 死 或 不死。

问题1是指一个老鼠不止喝一瓶奶，问题2是指一瓶牛奶是否有毒是可能有多只老鼠确定。也就是说**老鼠喝牛奶是牛奶的排列组合 和 牛奶是否有毒是老鼠的排列组合**。。

注意我们并不是想要全部列举出所有的牛奶N的排列组合，不然需要的老鼠个数就是2^N 了，**获取最少的老鼠我们需要用X只老鼠排列组合出N种状态。**也就是说2^X = N。老鼠个数应该为log2N (或log2N + 1)只。

假设有4瓶牛奶，0000表示这只老鼠一瓶牛奶也不喝。1000表示这只老鼠只喝第一瓶。我们准备2只老鼠。那么存在 两只死/两只都不死/一只死/另一只死 这四种状态，够表示4瓶牛奶了。比如说：
 鼠1:1010
 鼠2:0110

110. 有两个非负数a和b，求两者的和。注意a和b可能是小数，输出结果不包含多于的0。

     输入：

     12.3 5

     输出：

     17.5

111. 给定两个由数字0-9组成的字符数组，如“2345”，“4436”，从这两个数组分别取数，生成新数组。比如生成：44234365，生成方式如下图所示，每个数组取数放入新数组的时候，是按照下标从小到大取得。

     对于字符数组，定义跨度值：K(c)，为数字c最大下标和最小下标之差。比如数字44234365每个数字的K(c)定义如下：
     num   2  3 4 5 6  
     K(c)    0  2 4 0 0  
     请找到一种取合成方式，使得K(c)的总和最小（比如，上例总和为6，但总和并非最小）。打印出最小的K(c) 之和。

     输入:
     两个0-9组成的字符串first,second
     输出:
     最小和，是一个int类型
     输入范例:
     2345
     4436
     输出范例:

     5

112. ***饮料兑换活动\***
     阿里巴巴的食堂搞活动促销，已知某饮料1瓶3元钱，4个瓶盖可以换一瓶，2个空瓶可以换一瓶，则30元最多可以喝几瓶。
     输入：
     A //A表示饮料单价
     B //B表示瓶盖换瓶比
     C //C表示空瓶换瓶比
     D //D表示给定的钱数
     输出：S

113. 单词切割题
     题目为：
     给定一个字符串S和有效单词的字典D，请确定可以插入到S中的最小空格数，使得最终的字符串完全由D中的有效单词组成，并输出解。
     如果没有解则应该输出n/a
     例如
     输入
     S = “ilikealibaba”
     D = [“i”, “like”, “ali”, “liba”, “baba”, “alibaba”]
     Example Output:
     输出
     “i like alibaba”
     解释：
     字符串S可能被字典D这样拆分
     “i like ali baba”
     “i like alibaba”
     很显然，第二个查分结果是空格数最少的解。

114. 给定一串数字
     判断是否存在这三个元素，它们将数字串分为四个子串，其中每个子串的数字之和均相同(该3个元素不纳入计算)
     要求时间复杂度和空间复杂度均不能超过O(n)

115. 题目的描述：

     给定一个数组，里面全部是正整数。其数字大小表示这一步最多可以向后移动几个节点。总是从数组第一个元素开始移动。请问如何移动，可以以最少步数移动到最后一个节点。

     
     补充说明：给定数据是[3,4,2,1,3,1]。 初始状态指向3，表示下一步可以移动1格 或者 2格 或者3格。并能正确通过以下测试用例：

     ```js
     console.log(solve([4, 4, 9, 1, 3, 1, 8, 5])); //[4, 9, 5]
     console.log(solve([1, 3, 4, 2, 1, 1]));//[1, 3, 4, 1]
     ```

     

     思路如下：

     在找到最大值后记录下最大值在数组中的位置，同时将这个最大值与数组的最后一个元素进行比较如果相等就结束循环，如果不相等则判断最大值在当前在数组中的位置再加上最大值后是否超越了数组的长度，如果超越了数组的长度，则记录下数组的最后一个元素后结束循环。最后再控制好循环的条件就可以了。

     

     代码如下：

     ```js
     function solve(arr) {
         let len = arr.length;  // 数组的长度
         let maxPos = 0;  // 最大值的位置
         let path = [arr[0]];  // 记录经过的节点
         let lastVal = arr[len - 1];  // 数组的最后一个数
         let pos, posVal, maxVal;  // 初始化一些变量
     
         while (true) {
           maxVal = 0;  // 因为数组是正整数，所以0比任何一个数都小
           pos = maxPos;
           posVal = arr[pos];
     
           for (let i = pos + 1; i <= posVal + pos; i++) {
             if (arr[i] > maxVal) {
               maxVal = arr[i];  // 找到的最大值
               maxPos = i;  // 记录下最大值的位置
             }
           }
     
           path.push(maxVal);
     
           if (maxVal === lastVal) break;  // 正好到了数组的最后一个数
           else if (maxPos + maxVal > len - 1) {  // 直接超越了数组
             path.push(lastVal);  // 将最后一个数压入数组中
             break;
           }
         }
     
         return path;
     }
     ```

     上面的代码中，for循环中的条件设置时比较重要，变量i总是从当前位置的下一个位置开始，到当前位置加上数组当前位置上的数值。在循环中找到下一个最大值再记录下来。

     

     ## 测试

     ```js
     console.log(solve([3, 4, 2, 1, 3, 1, 4, 6]));  // [3, 4, 3, 6]
     console.log(solve([4, 4, 9, 1, 3, 1, 8, 5]));  // [4, 9, 5]
     console.log(solve([1, 3, 4, 2, 1, 1]));  // [1, 3, 4, 1]
     ```

116. 模拟Object.create

117. 实现JSON.parse

118. 回文判断

119. 实现数组解构destructuringArray方法

120. 实现sleep

121. 同时加载十万个元素

122. 插入排序

123. 爬楼梯问题/斐波纳契数列

124. 连续二进制

     计算一个整数的二进制表示中连续出现1最多的次数。

     比如13的二进制是：1101，那么他的二进制表示中连续出现的1最多为2次，所以答案就是2：

     输入描述:
     一个整数n表示要计算的数字。（1<=n<=1018）

     输出描述:
     输出一个数字表示n的二进制表示中连续出现1最多的次数。
     
125. 求最大公共前缀，如`['aaafsd', 'aawwewer', 'aaddfff'] => 'aa'`

126. 求最大公共路径前缀，`['aa/bb/sd', 'aa/bb/wwewer', 'aa/bb/ddfff'] => 'aa/bb'`
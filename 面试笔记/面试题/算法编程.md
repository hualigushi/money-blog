1. 算法，一个树结构，有id和一个子节点数组，要求在所有子节点上增加一个属性为父节点的parentId
2. 手写一个JSONP(promise版的)
3. 算法，实现一个螺旋矩阵
4. 有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，[2,1,4,3],这个算法的时间复杂度是多少
5. 完成一个Dialog组件，说说你设计的思路？它应该有什么功能？
6. 假设我现在有5000个圆，完全绘制出来，点击某一个圆，该圆高亮，另外4999个圆设为半透明，分别说说用svg和canvas怎么实现？  
   刚刚说的canvas的点击事件，怎么样实现？假如不是圆，这些图形是正方形、长方形、规则图形、不规则图形呢。
   那假如我的图形可能有变形、放大、偏移、旋转的需求呢？你的这个isPointInSide怎么处理？
   那个这个canvas的点击事件，点击的时候怎么样快速的从这5000个圆中找到你点击的那个圆（不完全遍历5000个节点）？
7. 手写函数的防抖和节流
8. 手写实现promise  手写promise的all方法
9. 手写vue的mixin方法
10. 如何实现一个可设置过期时间的localStorage
11. 实现一个发布订阅系统，包括on、emit、off等等    实现事件系统 eventEmitter
12. 用JavaScript的异步实现sleep函数
13. 手写快排，时间复杂度，优化
14. 手写实现jsonp
15. 设计一个单点登录的系统
16. 实现一个联想搜索组件
17. 有一个无序数组求中位数
18. 有一个数组和一个值，需要求大于等于该值的最小长度，例如[2, 3, 4, 7]和5，那么最小就是1，因为7大于5 如果数字是8，那么最小就是2, 因为4 + 7大于8
19. 有序数组中小于某个数的个数
20. 如何对请求进行缓存，例如有10个异步请求，如果有一个异步请求返回结果剩下的请求就用这个结果，并且能过传入成功和失败的回调函数
21. 实现(10).add(10).add(10)
22. 在从左向右和从上往下皆为升序的二维数组中，查找一个数是否存在，存在的话输出它的位置
23. 函数柯里化
24. 实现 ES6 的 class 语法
25. 图片懒加载
26. 洗牌算法
27. 实现一个deepClone需要兼容set、map、symbol、object,能成功克隆带有循环引用的对象
28. 用 Class 实现 EventEmitter，要求拥有 on，once，emit，off 方法
29. 实现 sum 函数
```
sum(1)(2)(3) == 6; // true
sum(1, 2, 3) == 6; // true
```
30. 用尾递归实现 fibonacci 数列
31. 代码实现中断 Promise 的运行
32. 实现以下功能，当对一个 arr 做 push 操作时，会自动打印一行提示消息
```
const arr = [1,2,3];
arr.push(4);
// arr pushed a new element: 4
```
33. 实现 co 函数
34. 有一组图片，实现后一张图片必须等到上一张图片加载完毕，才能开始加载
35. 为 Test 类添加方法，打印指定内容
```
class Test {
    constructor() {
        this.person = { name: "jack", age: 38, position: "CTO" };
    }
    // ......
}

const test = new Test();
for (const ele of test) {
    console.log(ele);
}
// [ 'name', 'jack' ]
// [ 'age', 38 ]
// [ 'position', 'CTO' ]
```
36. 实现 handler 函数，遇到 b 和 ac 都要去除
```
console.log(handler("aabaa")); // 'aaaa'
console.log(handler("abaccbc")); // 'c'
console.log(handler("aaccc")); // 'c'
console.log(handler("aaabccc")); // ''
```
37. 实现 decode 函数
`decode('HG[3|B[2|CA]]F') === 'HGBCACABCACABCACAF' // true`
38. 实现 _bind 函数，使打印 success
```
function Animal(name, color) {
  this.name = name;
  this.color = color;
}
Animal.prototype.say = function() {
  return `I'm a ${this.color} ${this.name}`;
};
const Cat = Animal._bind(null, "cat");
const cat = new Cat("white");
if (
  cat.say() === "I'm a white cat" &&
  cat instanceof Cat &&
  cat instanceof Animal
) {
  console.log("success");
}
```
39. CSS 实现圆环进度条效果
40. 给定任意非负整数，反复累加各位数字直到结果为个位数为止。例如给定非负整数912，第一次累加9+1+2 = 12, 第二次累加1+2 = 3, 3为个位数，循 环终止返回3
```
function add(num){
    if(isNaN(num)) return;
    if(num<10) return num
    const res=num.toString().split('').reduce((sum,value)=>{
        return sum+Number(value)
    },0)
    return add(res);
}
add(345);
3
```
41. add(1); // 1   add(1)(2);  // 3   add(1)(2)(3)；// 6
```
function add(a) {
    function sum(b) { // 使用闭包
        a = a + b; // 累加
        return sum;
     }
     sum.toString = function() { // 重写toString()方法
        return a;
    }
     return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)；// 6
```
44. 给定一个整数无序数组和变量 sum，如果存在数组中任意两项和使等于 sum 的值，则返回 true。否则,返回 false。例如，数组 [3,5,1,4]和 sum=9，函数应该返回 true，因为 4+5=9。

解决这个问题的一个很好的方法是遍历数组，创建 Set保存相对差值。

当我们遇到 3时，我们可以把 6加到 Set中, 因为我们知道我们需要找到 9的和。然后，每当我们接触到数组中的新值时，我们可以检查它是否在 Set 中。当遇到 5时，在 Set 加上4。最后，当我们最终遇到 4时，可以在 Set中找到它，就返回 true。
```
const findSum = (arr, val) => {  
  let searchValues = new Set();  
  searchValues.add(val - arr[0]);  
  for (let i = 1, length = arr.length; i < length; i++) {    
    let searchVal = val - arr[i];    
    if (searchValues.has(arr[i])) {      
      return true;    
    } else {      
      searchValues.add(searchVal);    
    }
    };  
  return false;
};
```
```
const findSum = (arr, sum) =>  arr.some((set => n => set.has(n) || !set.add(sum - n))(new Set));
```
因为 Set.prototype.has()的时间复杂度仅为 O(1)，所以使用 Set 来代替数组，最终使整个解决方案的线性运行时为 O(N)。

如果使用 Array.prototype.indexOf()或 Array.prototype.includes()，它们的时间复杂度都为 O(N)，则总运行时间将为 O(N²)，慢得多！

45. Node.js 中有一个queryString模块，可以实现将 urlStr 主机地址后面的参数转化为对象。

`let urlStr = 'http://www.inode.club?name=koala&study=js&study=node';`
转换结果如下:

`{ name: 'koala', study: [ 'js', 'node' ] }`
代码实现
```
let urlStr = 'http://www.inode.club?name=koala&study=js&study=node'
// 参数转成对象
function queryString(request){
    let params = request.split('?')[1];
    let param = params.split('&');
    let obj = {};
    for (let i = 0;i<param.length;i++){
        let paramsA = param[i].split('=');
        let key = paramsA[0];
        let value = paramsA[1];
        if(obj[key]){
            obj[key] = Array.isArray(obj[key])?obj[key]:[obj[key]];
            obj[key].push(value);
        }else{
            obj[key] = value;
        }
    }
    return obj;
}
console.log(queryString(urlStr));
```

46. 层次遍历一棵二叉树

47. 字符串中找出最长最多重复的子串

48. 无重复字符的最长子串

    ```
    var lengthOfLongestSubstring = function (s) {
        let obj = {} // 用于存储字符出现的位置
        let res = 0 // 位置
        let j = 0 // 不重复字符的index
    
        for (let i = 0; i < s.length; i++) {
            // 当前值是否在对象中存储过
            const value = obj[s[i]]
            if (value !== undefined) {
                // 更新上一次重复值的index
                // value + 1 跳过之前重复的字符
                // j : 之前不重复的index重复字符 需要全部跳过
                j = Math.max(value + 1, j)
            }
    
            // 每个字符都计算一下最长不重复值，保存最大值
            // 不重复最长长度 = 当前index - 上一次重复值的index + index 从0开始，长度从1开始
            res = Math.max(res, i - j + 1)
            obj[s[i]] = i
        }
    
        return res
    }
    
    
    
    var lengthOfLongestSubstring = function (s) {
        var i = 0, // 不重复字符的index
            res = 0 // 更新无重复字符的长度
        for (j = 0; j < s.length; j++) {
            // 查找：不重复字符-当前index之间 有没有出现当前字符
            let index = s.slice(i, j).indexOf(s[j])
            if (index === -1) {
                // 更新无重复字符 - 当前index之前 有没有出现当前字符
                res = Math.max(res, j - i + 1)
            } else {
                // 更新i = 不重复字符的index    
                // 不重复字符的index = 原不重复的字符index + i-j中出现重复字符的index + 跳过该重复字符
                i = i + index + 1
            }
        }
        return res
    }
    ```

49. 查找斐波纳契数列中第 N 个数

```
const fibonacci = (n) => {
    let arr = new Array(n).fill(0)
    arr[1] = 1
    for (let i=2;i<arr.length;i++) {
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[n-1]
}
```

50. 将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)

```
const reverseInteger = (n) => {
    if (n >= Math.pow(2, 31) - 1 || n <= Math.pow(-2, 31) + 1) {
        return 0
    }
    if (n < 0) {
        n = n.toString().split('-')[1]
        n = '-' + [...n].reverse().join('')
        n = +n
    } else {
        n = +[...n].reverse().join('')
    }
    return n
}

const reverseInteger = (n) => {
    if (n >= Math.pow(2, 31) - 1 || n <= Math.pow(-2, 31) + 1) {
        return 0
    }

    if (n === 0) {
        return 0
    }
    let res = 0
    while (n !== 0) {
        res = res * 10 + n % 10
        n = parseInt(n / 10)
    }
    return res
}
```

51. 数组交集差集并集

```
let one = [1, 2, 3, 4, 5];
let two = [2, 3, 4, 7];
const intersection = (a, b) => {
  // a b数组的交集
  let arr = a.filter(v => {
    // b是否包含a的元素，包含就返回true,交集
    return b.includes(v);
  });
  return arr;
};
const difference = (a, b) => {
  // a b 数组的差集
  let arr = [...a, ...b].filter(v => {
    // a和b是否包含v 不包含返回!false  出现有一个不包含(另一个数组就包含 找到差值),就返回true 添加进数组
    return !a.includes(v) || !b.includes(v);
  });
  return arr;
};

const unionArr = (a, b) => {
  return Array.from(new Set([...a, ...b])); // 并集可以理解为合并数组去重,直接用set即可
};
console.log(difference(one, two), intersection(one, two), unionArr(one, two));



function arrSet(a, b, type) {
  let set;
  a = new Set(a);
  b = new Set(b);
  if (type === 'difference') {
    // ab数组差集
    set = new Set([...a, ...b].filter(x => !b.has(x) || !a.has(x)));
  } else if (type === 'intersection') {
    // ab数组交集
    set = new Set([...a].filter(x => b.has(x)));
  } else {
    // ab数组并集
    set = new Set([...a, ...b]);
  }
  return Array.from(set); // 转为set
}
console.log(
  arrSet(one, two, 'difference'),
  arrSet(one, two, 'intersection'),
  arrSet(one, two, 'union')
);
```

52. 实现 promise.all 的 polyfill
53. 设计一个通过拖拽，然后交换位置的组件

54. 给定一个数组，请你按照升序 & 降序的规则去排列它

```
function bubble (arr, type) {
  function sortFn(a, b) {
     return type === 'up' ? a-b : b-a
  }
  return arr.sort(sortFn)
}
bubble([1, 4, 10, 2, 5, 18, 14], 'down')
```


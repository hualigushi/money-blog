## 定义
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。

创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。  

闭包产生的本质就是，当前环境中存在指向父级作用域的引用

**嵌套函数跨作用域使用变量就会产生闭包，使用变量的地方发生了闭包现象，定义变量的函数称为闭包函数**



## 原理
借助函数的立即执行、参数以及函数的return返回值，多创建了一层作用域。从而实现外部函数持续性被引用而不能释放内存空间，将值存储下来。  

函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。



- 当你从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即当前词法环境

- 闭包只会保留环境中任何变量的最后一个值，这是因为闭包所保存的是整个变量的对象

- 闭包的作用域链包含着它自己的作用域，以及包含它父级函数的作用域和全局作用域

- 当返回一个闭包时，保留此闭包下的所有被外部引用的对象

- 闭包之间是独立的，在闭包环境下可以创建多个不同的闭包环境暴露给外部，从而实现不同的效果

- 暴露闭包的方式不止返回内部函数一种，还可以使用回调函数产生闭包环境，或者把内部函数赋值给其他外部对象使用

- 闭包在没有被外部使用的情况下，随执行结束销毁，如何产生闭包并且保留闭包环境的关键就在于不让其环境被垃圾回收系统自动清除，那么就要使内部环境中的引用被外部保留，这样才能保留闭包






#### 优点

- 逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。
- 延长局部变量的生命周期, 更具有封装性, 保护局部变量。

#### 缺点

- 容易造成内存溢出
- 闭包会在父函数外部，改变父函数内部变量的值,所以可能会导致改变父函数的变量



### 表现形式

1. 返回一个函数
2. 作为函数参数传递

```
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

3. 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。

以下的闭包保存的仅仅是window和当前作用域。

```
// 定时器
setTimeout(function timeHandler(){
  console.log('111');
}，100)

// 事件监听
$('#app').click(function(){
  console.log('DOM Listener');
})
```

4. IIFE(立即执行函数表达式)创建闭包, 保存了`全局作用域window`和`当前函数的作用域`，因此可以全局的变量。

5. 单例模式

​     



## 缺点

1. 闭包常驻内存，内存消耗很大
2. 可能导致内存泄露。解决方案：在退出函数之前，将不使用的局部变量全部删除。

```
function a(){
  var i=0;
  function b(){
      alert(++i);
  }
  return b;
}
var c=a();
c();  // 1
c();  // 2
c();  // 3
```
这段代码有两个特点：  
1. 函数b嵌套在函数a内部；  
2. 函数a返回函数b。  

这样在执行完`var c=a( )`后，变量c实际上是指向了函数b，再执行c( )后就会弹出一个窗口显示i的值（第一次为1）。  
这段代码其实就创建了一个闭包，这是因为函数a外的变量c引用了函数a内的函数b。  
也就是说，当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。  

c指向的对象会永远存在堆内存中,即使是a已经执行完毕  

c = null;   //如果val不再使用，将其指向的对象释放  



```
function fn3(){
    var a = 10;
    return function(){
        a--;
        console.log(a);
    }
}
fn3()();//9
fn3()();//9
```
当fn3()()第一次执行完后，整个fn3()被销毁，第二次fn3()相当于重新开辟了一块新的空间，所以第二次fn3()()和第一次打印的结果无关。





```
var f3;
function f1() {
  var a = 2
  f3 = function() {
    console.log(a);
  }
}
f1();
f3();
```

让f1执行，给f3赋值后，等于说现在`f3拥有了window、f1和f3本身这几个作用域的访问权限`，还是自底向上查找，`最近是在f1`中找到了a,因此输出2。

在这里是外面的变量`f3存在着父级作用域的引用`，因此产生了闭包，形式变了，本质没有改变。







```
function foo(){
  let a={name:'me'}
  let b={who:'isMe'}
  let wm=new WeakMap()
  function bar(){
    console.log(a)  // a被闭包保留
    wm.set(b,1) // 弱引用b对象
    return wm //wm被闭包保留
  }
  return bar
}
const wm=foo()()
console.dir(wm) // No properties 即为空
-------------------------------------------
function foo(){
  let a={name:'me'}
  let wm=new WeakMap()
  function bar(){
    console.log(a)
    wm.set(a,1)
    return wm
  }
  return bar
}
const wm=foo()()
console.dir(wm) // 保存了对象a与其值1
```

- 从上块代码中可以看出，bar被return到外部环境，所以其内部形成闭包，bar中使用到的变量(a,wm)都会被保留下来，但是最后打印wm的时候为空？这是因为外部并没有引用到b对象，只是通过wm弱引用保存b的值，从wm为空可以看出，闭包内部的b被清除，所以wm也自动清除b的弱引用，可以论证之前所说，闭包只保留外部用到的变量

- 从下块代码能直接看出a就是闭包中的a，bar在外部执行时需要用到a与wm所以保留了下来

- 有人可能会不解，为什么上块代码中的b也被wm.set(b,1)引用，但是最终就没有呢，那是因为WeakMap中保留的是b的弱引用，可以理解为，wm中的b是依赖原函数中的b而存在，当wm被return时，闭包中的b，没有被任何外部所依赖，而是别人依赖它。可以这么理解 b牵着别人走，因为b没有被外面人牵着走，所以b这个链子就被断开，也影响到b牵的人一块丢了











当一个嵌套的函数在定义(作用域)的外面被访问，以至它可以在外部函数返回后被执行，此时一个闭包形成。它(闭包)维护(在内部函数中)对外部函数中局部变量，arguments和函数声明的访问。封装允许我们从外部作用域中隐藏和保护执行上下文，而暴露公共接口，通过接口进一步操作。



**当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的**。
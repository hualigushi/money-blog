## 定义
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。

创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。  

闭包产生的本质就是，当前环境中存在指向父级作用域的引用



## 原理
借助函数的立即执行、参数以及函数的return返回值，多创建了一层作用域。从而实现外部函数持续性被引用而不能释放内存空间，将值存储下来。  

函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。



## 作用

1. 封装私有变量

2. 模仿块级作用域 (ES5 中没有块级作用域)

3. 实现 JS 的模块

   

## 优点
1. 避免全局变量被污染
2. 方便调用上下文的局部变量
3. 加强封装性



### 表现形式

1. 返回一个函数
2. 作为函数参数传递

```
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

3. 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。

以下的闭包保存的仅仅是window和当前作用域。

```
// 定时器
setTimeout(function timeHandler(){
  console.log('111');
}，100)

// 事件监听
$('#app').click(function(){
  console.log('DOM Listener');
})
```

4. IIFE(立即执行函数表达式)创建闭包, 保存了`全局作用域window`和`当前函数的作用域`，因此可以全局的变量。

5. 单例模式

​       比如一个遮罩层的创建，为确保一次只有一个遮罩层，使用单例模式是最好的选择。

        ```
var singleton = function( fn ){
    var result;
    
    return function(){
        return result || ( result = fn .apply( this, arguments ) );
    }
}

var createMask = singleton(
    function(){
        return document.body.appendChild( document.createElement('div') );
    }
)
        ```





## 缺点

1. 闭包常驻内存，内存消耗很大
2. 可能导致内存泄露。解决方案：在退出函数之前，将不使用的局部变量全部删除。

```
function a(){
  var i=0;
  function b(){
      alert(++i);
  }
  return b;
}
var c=a();
c();  // 1
c();  // 2
c();  // 3
```
这段代码有两个特点：  
1. 函数b嵌套在函数a内部；  
2. 函数a返回函数b。  

这样在执行完`var c=a( )`后，变量c实际上是指向了函数b，再执行c( )后就会弹出一个窗口显示i的值（第一次为1）。  
这段代码其实就创建了一个闭包，这是因为函数a外的变量c引用了函数a内的函数b。  
也就是说，当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。  

c指向的对象会永远存在堆内存中,即使是a已经执行完毕  

c = null;   //如果val不再使用，将其指向的对象释放  



```
function fn3(){
    var a = 10;
    return function(){
        a--;
        console.log(a);
    }
}
fn3()();//9
fn3()();//9
```
当fn3()()第一次执行完后，整个fn3()被销毁，第二次fn3()相当于重新开辟了一块新的空间，所以第二次fn3()()和第一次打印的结果无关。





```
var f3;
function f1() {
  var a = 2
  f3 = function() {
    console.log(a);
  }
}
f1();
f3();
```

让f1执行，给f3赋值后，等于说现在`f3拥有了window、f1和f3本身这几个作用域的访问权限`，还是自底向上查找，`最近是在f1`中找到了a,因此输出2。

在这里是外面的变量`f3存在着父级作用域的引用`，因此产生了闭包，形式变了，本质没有改变。
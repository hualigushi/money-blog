## 定义
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。

创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。  



## 原理
借助函数的立即执行、参数以及函数的return返回值，多创建了一层作用域。从而实现外部函数持续性被引用而不能释放内存空间，将值存储下来。  

函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。



## 作用

1. 封装私有变量

2. 模仿块级作用域 (ES5 中没有块级作用域)

3. 实现 JS 的模块

   

## 优点
1. 避免全局变量被污染
2. 方便调用上下文的局部变量
3. 加强封装性



## 缺点

1. 闭包常驻内存，内存消耗很大
2. 可能导致内存泄露。解决方案：在退出函数之前，将不使用的局部变量全部删除。

```
function a(){
  var i=0;
  function b(){
      alert(++i);
  }
  return b;
}
var c=a();
c();  // 1
c();  // 2
c();  // 3
```
这段代码有两个特点：  
1. 函数b嵌套在函数a内部；  
2. 函数a返回函数b。  

这样在执行完`var c=a( )`后，变量c实际上是指向了函数b，再执行c( )后就会弹出一个窗口显示i的值（第一次为1）。  
这段代码其实就创建了一个闭包，这是因为函数a外的变量c引用了函数a内的函数b。  
也就是说，当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。  

c指向的对象会永远存在堆内存中,即使是a已经执行完毕  

c = null;   //如果val不再使用，将其指向的对象释放  



```
function fn3(){
    var a = 10;
    return function(){
        a--;
        console.log(a);
    }
}
fn3()();//9
fn3()();//9
```
当fn3()()第一次执行完后，整个fn3()被销毁，第二次fn3()相当于重新开辟了一块新的空间，所以第二次fn3()()和第一次打印的结果无关。

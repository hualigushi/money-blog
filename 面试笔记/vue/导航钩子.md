① 全局导航守卫

前置守卫
```
router.beforeEach((to, from, next) => {
  // do someting
});
```
后置钩子（没有next参数）
```
router.afterEach((to, from) => {
  // do someting
});
```
②路由独享守卫
```
cont router = new  VueRouter({
 routes: [
  {
    path: '/file',
    component: File,
    beforeEnter: (to, from ,next) => {
       // do someting
    }
   }
 ]
});
```
顺便看一下路由里面的参数配置：

③ 组件内的导航钩子

组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的
```
beforeRouteEnter

data(){
 return{
   pro:'产品'
 }
},
beforeRouteEnter:(to,from,next)=>{
  console.log(to)
  next(vm => {
   console.log(vm.pro)
  })
}
```
注：beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前，组件实例被没有被创建出来，我们可以通过给 next 传入一个回调来访问组件实例。
在导航被确认时，会执行这个回调，这时就可以访问组件实例了

仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持，因为剩下两个钩子可以正常获取组件实例 this

如何通过路由将数据传入下一个跳转的页面呢？

答： params 和 query

params
```
传参
this.$router.push({
 name:"detail",
 params:{
   name:'xiaoming',
 }
});
接受
this.$route.params.name
```

query
```
传参
this.$router.push({
  path:'/detail',
  query:{
    name:"xiaoming"
  }
 })
接受 //接收参数是this.$route
this.$route.query.id  
```

那query和params什么区别呢？

① params只能用name来引入路由，query既可以用name又可以用path（通常用path）

② params类似于post方法，参数不会再地址栏中显示


query类似于get请求，页面跳转的时候，可以在地址栏看到请求参数


那刚才提到的this.$router 和this.$route有何区别？

$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法

$route为当前router跳转对象，里面可以获取name、path、query、params等

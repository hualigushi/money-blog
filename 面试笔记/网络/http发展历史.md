## HTTP 发展历史

### HTTP 0.9 版本

- 只有一个 `GET` 命令。
- 没有请求头和响应头来描述传输相关的数据信息。
- 服务器发送完数据后，直接关闭 `TCP` 连接，不支持 `TCP` 持久化连接。

### HTTP 1.0 版本

- 增加了很多命令，`HEAD`、`POST`、`PUT`、`DELETE` 等。
- 增设了 `status code` 状态码和 `header` 请求头和响应头。
- 增加了多字符集支持、多部分发送、权限、缓存等。
- 可通过开启 `Connection： keep-alive` 来指定使用 `TCP` 长连接

### HTTP 1.1 （目前普遍使用）

- 默认支持持久连接
- 默认支持长连接（PersistentConnection），即默认开启 `Connection： keep-alive`。
- 支持请求的流水线（Pipelining）处理，即在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应。
- 增加了 `host` 请求头字段，通过对 `host` 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 `nginx` 反向代理就是根据 `HTTP` 请求头中的 `host` 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。

### HTTP 2.0

- `HTTP1.x` 的解析是基于文本，存在解析上的缺陷；而 `HTTP2.0` 直接使用二进制的解析方式来替代 `HTTP 1.X` 的字符串解析，更为高效和健壮。
- `HTTP2.0` 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并行的数据传输。
- `HTTP2.0` 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
- `HTTP2.0` 压缩头信息进行传输数据量的优化。`HTTP1.x` 的请求头带有大量信息，而且每次都要重复发送，`HTTP2.0` 使用 `encoder` 来减少需要传输的请求头大小，通讯双方各自缓存一份 `header fields` 表，既避免了重复的传输，又减小了传输信息的大小。
- `HTTP2.0` 新增了 `server push`（服务端推送） 的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。
- 目前如果要使用 `HTTP2` 需要首先使用 `HTTPS` 在这基础上，才能使用 `HTTP2`

> `HTTP 2.0` 相比于 `HTTP 1` 最直观的图片加载性能提升



##### 多路复用

多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过**一个 TCP连接并发完成**。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制

HTTP/2 便从 HTTP 协议本身解决了`队头阻塞`问题。注意，这里并不是指的`TCP队头阻塞`，而是`HTTP队头阻塞`，两者并不是一回事。TCP 的队头阻塞是在`数据包`层面，单位是`数据包`，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 `HTTP 请求-响应`层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。



在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。这一特性，使性能有了极大提升
- 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。




##### 头部压缩

HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。

HTTP每一次通信都会携带一组头部，用于描述这次通信的的资源、浏览器属性、cookie等

为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：

HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；

首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;

每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。



##### 更安全的SSL

HTTP2.0使用了tls的拓展ALPN来做协议升级，除此之外加密这块还有一个改动，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法，一些加密算法可能还在被继续使用。如果在ssl协商过程当中，客户端和server的cipher suite没有交集，直接就会导致协商失败，从而请求失败。在server端部署http2.0的时候要特别注意这一点。



### HTTP/3 QUIC

##### HTTP 2问题

1. 在底层使用了TCP的情况下，TCP的慢启动；拥塞窗口尺寸设置不合理导致的性能急剧下降的问题没有得到解决。
2. HTTP 2多路复用只是减少了连接数，队头阻塞的问题并没有得到完全解决。如果TCP丢包率超过2%，HTTP/2表现将不如HTTP1.1。因为HTTP1 是分开使用的TCP连接,具体对比如下示意图所示：

#####  ![](https://upload-images.jianshu.io/upload_images/6301972-9482e8b53c342058.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp) HTTP3特点

- HTTP 3是在QUIC基础上发展出来的。**底层使用UDP进行数据传输**，但上层仍然使用HTTP/2。HTTP2与UDP之前存在一个QUIC层，TLS加密过程在此层处理。

- **从协议本身保证了安全性**，QUIC在建立连接的握手过程中就完成了TLS加密握手

- **建立连接快**，正常只需要1RTT即可建立连接。如果有缓存之前的secret信息，则直接验证和建立连接，此过程0RTT。建立连接时，也可以带有少量业务数据。

- **不和具体底层连接绑定**，QUIC为每个连接的两端分别分配了一个唯一ID，上层连接只认这对逻辑ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立

- **使用QPACK进行头部压缩**，因为HPACK要求传输过程有序，这会导致队头阻塞。而QPACK不存在这个问题

- HTTP/3在header中定义了一个新header:`Alt-Svc: h3=":20003"`:表示服务器在20003端口开了一个20003端口用于HTTP/3服务

  

##### **HTTP/3 问题与挑战**

UDP 连通性问题

QUIC 不支持明文传输

UDP 消耗资源多

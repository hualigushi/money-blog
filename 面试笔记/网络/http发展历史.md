## HTTP 发展历史

### HTTP 0.9 版本

- 只有一个 `GET` 命令。
- 没有请求头和响应头来描述传输相关的数据信息。
- 服务器发送完数据后，直接关闭 `TCP` 连接，不支持 `TCP` 持久化连接。

### HTTP 1.0 版本

- 增加了很多命令，`HEAD`、`POST`、`PUT`、`DELETE` 等。
- 增设了 `status code` 状态码和 `header` 请求头和响应头。
- 增加了多字符集支持、多部分发送、权限、缓存等。
- 可通过开启 `Connection： keep-alive` 来指定使用 `TCP` 长连接

### HTTP 1.1 （目前普遍使用）

- 默认支持持久连接
- 默认支持长连接（PersistentConnection），即默认开启 `Connection： keep-alive`。
- 支持请求的流水线（Pipelining）处理，即在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应。
- 增加了 `host` 请求头字段，通过对 `host` 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 `nginx` 反向代理就是根据 `HTTP` 请求头中的 `host` 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。

### HTTP 2.0

- `HTTP1.x` 的解析是基于文本，存在解析上的缺陷；而 `HTTP2.0` 直接使用二进制的解析方式来替代 `HTTP 1.X` 的字符串解析，更为高效和健壮。
- `HTTP2.0` 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并行的数据传输。
- `HTTP2.0` 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
- `HTTP2.0` 压缩头信息进行传输数据量的优化。`HTTP1.x` 的请求头带有大量信息，而且每次都要重复发送，`HTTP2.0` 使用 `encoder` 来减少需要传输的请求头大小，通讯双方各自缓存一份 `header fields` 表，既避免了重复的传输，又减小了传输信息的大小。
- `HTTP2.0` 新增了 `server push`（服务端推送） 的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。
- 目前如果要使用 `HTTP2` 需要首先使用 `HTTPS` 在这基础上，才能使用 `HTTP2`

> `HTTP 2.0` 相比于 `HTTP 1` 最直观的图片加载性能提升



##### 多路复用

多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制

在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。这一特性，使性能有了极大提升
- 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。



##### 服务器推送

server push

http2.0能通过push的方式将客户端需要的内容预先推送过去，所以也叫“cache push”。另外有一点值得注意的是，客户端如果退出某个业务场景，出于流量或者其它因素需要取消server push，也可以通过发送RST_STREAM类型的frame来做到。




##### 头部压缩

HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。

HTTP每一次通信都会携带一组头部，用于描述这次通信的的资源、浏览器属性、cookie等

为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：

HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；

首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;

每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。



##### 更安全的SSL

HTTP2.0使用了tls的拓展ALPN来做协议升级，除此之外加密这块还有一个改动，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法，一些加密算法可能还在被继续使用。如果在ssl协商过程当中，客户端和server的cipher suite没有交集，直接就会导致协商失败，从而请求失败。在server端部署http2.0的时候要特别注意这一点。

[demo](https://http2.akamai.com/demo)



## HTTP 性能优化方案

1. 合理使用 `HTTP` 的缓存策略，避免同一资源多次请求服务端而导致的额外性能开销
2. 尽量使用 `HTTP` 长连接，避免每次重建 `TCP` 连接带来的时间损耗
3. 尽量使用 `HTTPS` 来保证网络传输的安全性。
4. 可以使用 `HTTP2` 来大幅提高数据传输的效率，使用 `server push` 开启 `HTTP2` 的服务端推送功能
5. 客户端开启 `Accept-Encoding` 压缩方式的支持，服务端传输压缩后的文件，减少传输数据的大小



#### 面试题：`http2.0`的二进制分帧底层相关，这个二进制传输相对于文本传输有什么区别，文本最终不应该也是转为二进制进行传输吗，流、消息是什么？

主要是指 header 部分的传输
二进制编码可以更高效率的压缩
比如 content-type 占 12 字节，enum key 就只占一到两个字节

![](https://img-blog.csdn.net/20180611105209645?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdndW9zYg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**为什么使用二进制协议？**

1. 性能。二进制协议的解析效率超高，几乎没有解析代价；
2. 带宽。二进制协议没有冗余字段，占用带宽少；
3. 压缩及Https技术弱化了文本协议的价值；
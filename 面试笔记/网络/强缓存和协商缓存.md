缓存策略的分类：

- 强缓存
- 协商缓存

缓存策略都是通过设置 HTTP Header 来实现的。
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。
浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。



# 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

##### 1. Expires

**缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和`Last-modified`结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在` Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。

##### 2. Cache-Control

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。
Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：

**Cache-Control的属性**

**public**：表示响应可以被客户端和代理服务器缓存
**private**：表示响应只能被客户端缓存
**max-age=30**：表示缓存有效时间为30s，超过30s需要重新请求
**s-maxage=30**：覆盖max-age，作用同max-age，只在代理服务器生效
**no-sotre**：不会缓存响应
**no-cache**：客户端缓会存资源，是否使用缓存则需要经过协商缓存来验证决定。需要注意，no-cache并不是不缓存响应资源，而是缓存后，要通过协商缓存来确定是否使用缓存。
**max-stale=30**：能接受的最大过期时间为30s，在30s秒内，即使缓存已经过期，也是要缓存。
**min-fresh=30**：表示希望在30s内获取最新的响应。



##### 3. Expires和Cache-Control两者对比

其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。

**强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容**，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。



# 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回304和Not Modified
- 协商缓存失效，返回200和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

##### 1. Last-Modified 和 If-Modified-Since

浏览器在第一次访问资源时，服务器返回资源的同时，在`response header`中添加` Last-Modified 的header`，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；

```
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

浏览器下一次请求这个资源，浏览器检测到有` Last-Modified`这个header，于是添加`If-Modified-Since`这个header，值就是`Last-Modified中`的值；服务器再次收到这个资源请求，会根据 `If-Modified-Since`中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果`If-Modified-Since`的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。
**但是 Last-Modified 存在一些弊端：**

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified `被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 `ETag` 和`If-None-Match`

##### 2. ETag 和 If-None-Match

**Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成**。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的`If-None-Match`里，服务器只需要比较客户端传来的`If-None-Match`跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

##### 3. 两者之间对比：

- 首先在精确度上，Etag要优于Last-Modified。

Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

- 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。

- 第三在优先级上，服务器校验优先考虑Etag

  

####  缓存机制

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。

####  强缓存与协商缓存的区别

强缓存与协商缓存的区别可以用下表来表示：

| 缓存类型 | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 是，通过服务器来告知缓存是否可用 |


用户行为对缓存的影响

| 用户操作        | Expires/Cache-Control | Last-Modied/Etag |
| --------------- | --------------------- | ---------------- |
| 地址栏回车      | 有效                  | 有效             |
| 页面链接跳转    | 有效                  | 有效             |
| 新开窗口        | 有效                  | 有效             |
| 前进回退        | 有效                  | 有效             |
| F5刷新          | 无效                  | 有效             |
| Ctrl+F5强制刷新 | 无效                  | 无效             |






![200 304](https://upload-images.jianshu.io/upload_images/1726248-8af74e5ab792e71f.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)





# 缓存策略

HTTP的缓存技术主要是为了提升网站的性能，如果不考虑客户端缓存容量和服务器计算能力的理想情况，当然希望客户端浏览器上的缓存触发率尽可能高，留存时间尽可能长，同时还要ETag实现当资源更新时进行高效的重新验证。

但实际情况往往是容量和计算能力都有限，因此就需要指定合适的缓存策略，利用有效的资源达到最优的性能效果。

明确需求边界，力求在边界内做到最好。

在使用缓存技术优化性能的过程中，有一个问题是不可逾越的，既希望缓存能在客户端尽可能长久的保存，又希望他能在资源发生修改时进行及时更新。这是两个互斥的需求。如何兼顾二者呢？

可以将网站所需要的资源按照不同的类型去拆解，为不同类型的资源制定相应的缓存策略。

1. 首先HTML文件是包含其他文件的主文件，为保证当其发生改变能及时更新，应该将其设置为协商缓存.

`cache-control: no-cache`

2. 图片文件的修改基本都是替换，同时考虑图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可以采用强制缓存且过期时间不宜过长。

`cache-control: max-age=86400`

3. css样式表属于文本文件，可能存在的内容不定期修改，还想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加指纹或版本号(一般为hash值)，这样发生修改后不同的文件便会有不同的文件指纹，也就是请求的url不同。所以css的缓存时间可以设置长一些, 一年。

`cache-control: max-age=31536000`

4. js脚本文件可以类似样式表的设置，采用指纹和较长的过期时间，如果js中包含了用户的私人信息而不想让中间代理缓存，可添加private属性。
   `cache-control: private, max-age=31536000`

缓存策略就是为不同的资源进行组合使用强制缓存，协商缓存及文件指纹或版本号，这样可以做到一举多得，及时修改更新，较长缓存过期时间及控制所能进行缓存的位置。



缓存设置需要注意不存在适用于所有场景下的最佳缓存策略，凡是恰当的缓存策略都需要根据具体的场景考虑制定。缓存决策要考虑下面几种情况。

#### 1. 拆分源码，分包加载
对于大型项目来说，代码里是非常庞大的，如果发生修改的部分集中在几个重要的模块中，那么进行全量的代码更新显然比较冗杂，因此可以考虑在代码构建过程中按照模块拆分将其打包成多个单独的文件。

这样在每次修改后更新提取时，仅需拉取发生改变的模块代码包，从而大大降低了需要下载的内容大小。

#### 2. 预估资源的缓存时效
根据不同资源的不同需求特点来规划响应的缓存更新失效，为强制缓存指定合适的max-age，为协商缓存提供验证更新的ETag实体标签。

#### 3. 控制中间代理的缓存
凡是涉及用户隐私信息的尽量避免中间代理的缓存，如果对所有用户响应相同的资源，则可以考虑让中间代理也进行缓存。

#### 4. 避免网址的冗余
缓存是根据请求资源的URL进行的，不同的资源会有不同的URL，所以尽量不要将相同的资源设置为不同的URL。这会导致缓存失效。

#### 5. 规划缓存的层次结构
不仅请求的资源类型，文件资源的层次结构也会对制定缓存策略有一定的影响。






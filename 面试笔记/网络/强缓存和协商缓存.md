缓存策略的分类：

- 强缓存
- 协商缓存

缓存策略都是通过设置 HTTP Header 来实现的。
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。
浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

#### 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

##### 1. Expires

**缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和`Last-modified`结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在` Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。

##### 2. Cache-Control

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。
Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：

**Cache-Control的属性**

**public**：表示响应可以被客户端和代理服务器缓存
**private**：表示响应只能被客户端缓存
**max-age=30**：表示缓存有效时间为30s，超过30s需要重新请求
**s-maxage=30**：覆盖max-age，作用同max-age，只在代理服务器生效
**no-sotre**：不会缓存响应
**no-cache**：客户端缓会存资源，是否使用缓存则需要经过协商缓存来验证决定。需要注意，no-cache并不是不缓存响应资源，而是缓存后，要通过协商缓存来确定是否使用缓存。
**max-stale=30**：能接受的最大过期时间为30s，在30s秒内，即使缓存已经过期，也是要缓存。
**min-fresh=30**：表示希望在30s内获取最新的响应。



##### 3. Expires和Cache-Control两者对比

其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。

**强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容**，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。





#### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回304和Not Modified
- 协商缓存失效，返回200和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

##### 1. Last-Modified 和 If-Modified-Since

浏览器在第一次访问资源时，服务器返回资源的同时，在`response header`中添加` Last-Modified 的header`，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；

```
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

浏览器下一次请求这个资源，浏览器检测到有` Last-Modified`这个header，于是添加`If-Modified-Since`这个header，值就是`Last-Modified中`的值；服务器再次收到这个资源请求，会根据 `If-Modified-Since`中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果`If-Modified-Since`的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。
**但是 Last-Modified 存在一些弊端：**

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified `被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 `ETag` 和`If-None-Match`

##### 2. ETag 和 If-None-Match

**Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成**。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的`If-None-Match`里，服务器只需要比较客户端传来的`If-None-Match`跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

##### 3. 两者之间对比：

- 首先在精确度上，Etag要优于Last-Modified。

Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

- 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。

- 第三在优先级上，服务器校验优先考虑Etag

  

####  缓存机制

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。

####  强缓存与协商缓存的区别

强缓存与协商缓存的区别可以用下表来表示：

| 缓存类型 | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 是，通过服务器来告知缓存是否可用 |


用户行为对缓存的影响

| 用户操作        | Expires/Cache-Control | Last-Modied/Etag |
| --------------- | --------------------- | ---------------- |
| 地址栏回车      | 有效                  | 有效             |
| 页面链接跳转    | 有效                  | 有效             |
| 新开窗口        | 有效                  | 有效             |
| 前进回退        | 有效                  | 有效             |
| F5刷新          | 无效                  | 有效             |
| Ctrl+F5强制刷新 | 无效                  | 无效             |







# 浏览器缓存，状态码200与304

**200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存**

**304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存**  



304 Not Modified 比 200 OK (from cache) 慢，指的是浏览器还向服务器确认了下 "If-Not-Modified"，才用的缓存

**在客户端强制刷新，如ctrl+f5这种情况下，所有的缓存策略失效，服务器端都会返回200**

**在客户端非强制刷新，如点击刷新按钮或按f5的情况下，服务器端会根据request头中：If-Modified-Since字段的时间与文件的实际修改时间进行比较**




![200 304](https://upload-images.jianshu.io/upload_images/1726248-8af74e5ab792e71f.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)










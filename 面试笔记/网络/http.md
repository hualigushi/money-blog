# 业务场景：比如说百度的一个服务不想让阿里使用，如果识别到是阿里的请求，然后跳转到404或者拒绝服务之类的？

主要是考察http协议头Referer



# 面试题：`http2.0`的二进制分帧底层相关，这个二进制传输相对于文本传输有什么区别，文本最终不应该也是转为二进制进行传输吗，流、消息是什么？

主要是指 header 部分的传输
二进制编码可以更高效率的压缩
比如 content-type 占 12 字节，enum key 就只占一到两个字节

![](https://img-blog.csdn.net/20180611105209645?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdndW9zYg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**为什么使用二进制协议？**

1. 性能。二进制协议的解析效率超高，几乎没有解析代价；
2. 带宽。二进制协议没有冗余字段，占用带宽少；
3. 压缩及Https技术弱化了文本协议的价值；



# HTTP首部（Header）和实体（Body）的分隔符是什么

HTTP协议规定，HTTP首部（headers）和HTTP主体之间是以一个空行分割的。因为HTTP每一行（每一行是指一个头部字段）是以`\r\n`结束的，一个空行的`\r\n`，再加上最后一行的结束符`\r\n`，一起是`\r\n\r\n`，也就是说，当检测到`\r\n\r\n`四个字符时，下一个字符开始就是HTTP body的内容了。



# http强行使用udp能实现吗

**HTTP 不可以基于 UDP 传输**




# HTTP 性能优化方案

1. 合理使用 `HTTP` 的缓存策略，避免同一资源多次请求服务端而导致的额外性能开销
2. 尽量使用 `HTTP` 长连接，避免每次重建 `TCP` 连接带来的时间损耗
3. 尽量使用 `HTTPS` 来保证网络传输的安全性。
4. 可以使用 `HTTP2` 来大幅提高数据传输的效率，使用 `server push` 开启 `HTTP2` 的服务端推送功能
5. 客户端开启 `Accept-Encoding` 压缩方式的支持，服务端传输压缩后的文件，减少传输数据的大小



# HTTP 状态码

![](https://img-blog.csdnimg.cn/20190530105724767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lkd3R3dA==,size_16,color_FFFFFF,t_70)



# 401 403

401 Unauthorized： 该HTTP状态码表示认证错误，它是为了认证设计的，而不是为了授权设计的。收到401响应，表示请求没有被认证—压根没有认证或者认证不正确—但是请重新认证和重试。（一般在响应头部包含一个WWW-Authenticate来描述如何认证）。通常由web服务器返回，而不是web应用。从性质上来说是临时的东西。（服务器要求客户端重试）

403 Forbidden：该HTTP状态码是关于授权方面的。从性质上来说是永久的东西，和应用的业务逻辑相关联。它比401更具体，更实际。收到403响应表示服务器完成认证过程，但是客户端请求没有权限去访问要求的资源。



# 301、302、303、307状态码的区别

#### 301永久重定向

#### 302临时重定向，HTTP1.0的状态码，HTTP1.1也有保留。
如果client向server发送post请求。
server返回URL和302。
如果用户确认，client发送post请求。（但实际情况是，很多浏览器都不问问用户，直接变为get发送get请求）

#### 303临时重定向，HTTP1.1的状态码
发送Post请求，收到303，直接重定向为get，发送get请求，不需要向用户确认

#### 307临时重定向，HTTP1.1的状态码
客户端发送post请求返回307时，浏览器询问用户是否再次post





# 浏览器缓存，状态码200与304

**200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存**

**304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存**  



304 Not Modified 比 200 OK (from cache) 慢，指的是浏览器还向服务器确认了下 "If-Not-Modified"，才用的缓存

**在客户端强制刷新，如ctrl+f5这种情况下，所有的缓存策略失效，服务器端都会返回200**

**在客户端非强制刷新，如点击刷新按钮或按f5的情况下，服务器端会根据request头中：If-Modified-Since字段的时间与文件的实际修改时间进行比较**




![200 304](https://upload-images.jianshu.io/upload_images/1726248-8af74e5ab792e71f.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)








## 防止http请求数据被篡改

### 1.设置客户端IP黑/白名单

1.1.客户端所有请求，请求到代理服务器(nginx)，代理服务器维护黑/白名单的ip，决定是否转发请求。

1.2.项目创建一个filter，拦截所有请求，在filter的方法中，通过request信息匹配ip黑/白名单，和url的拦截规则，决定是否合法。

优点：简单粗暴。

缺点：需要客户端的IP固定。

应用场景：并发量小的场景。比如系统的后台管理服务，客服需要人工审批和通过涉及到钱财的业务，就可以使用这种简单粗暴的方式，防止账号泄露，接口泄露等等。



### 2.请求参数Sign签名

2.1前端发起http请求，对参数排序，然后使用 参数与私钥拼接，在进行md5加密 等方式，生成一个签名出来，一起发给服务端，服务端这边获取到参数，签名，再使用自己的私钥进行同样方式的加密生成签名，比对签名是否一致。一致则认为合法，不一致则不合法。**但是无法防止重复请求攻击！**

2.2针对上面方法升级，可以缓存每次请求的md5值，或者给每个请求添加uuid+随机数这样一个代表请求序号的标识。然后请求到服务端时，服务端想办法缓存起来起来这个标识，每次请求过来时，判断是否已经请求过。**但是缓存怎么实现，如何维护？而且并发量高的话，每个请求过来都先查缓存，是否影响性能。**

2.3在请求的参数中和签名结果里，加入时间戳这个参数，业务服务器一方面比较签名结果，一方面根据时间戳，来认证请求的合法性，比如允许请求的时间戳与服务器当前时间，存在20秒的误差等自定义规则。超过20秒的合法请求，服务器也不处理，防止恶意的重复请求。

2.4时间戳+md51 时间差120s以上代表重复请求，md5写缓存，缓存时长120s（大于等于上面的值就行），判断如果有md5代表重复请求。



### 3.请求方式换成Https
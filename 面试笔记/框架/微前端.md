微前端的核心是解决巨石应用，它都有这些特点：

- 简单、松耦合的代码库

- - 微前端架构倾向于编写和维护更小、更简单、更容易开发的项目。
  - 技术栈无关，各项目可以使用不同的技术栈。

- 增量升级

- - 支持渐进式重构，先让新旧代码和谐共存，再逐步转化旧代码，直到整个重构完成。

- 独立部署

- - 每一个子应用都具备独立开发，持续部署，独立运行的能力。

- 团队自治

- - 各子项目之间不存在依赖关系，保持隔离。
  - 单一职责，每个子项目只做和自己相关的业务工作。



当然，微前端也不是万能的，它也存在以下问题：

- 拆分的粒度越小，便意味着架构变得复杂、维护成本变高。
- 技术栈一旦多样化，便意味着技术栈混乱。
- 管理版本复杂、依赖复杂。
- 开发体验不太友好，开发时可能需要同时启动多个项目。

这些问题大多是因为项目拆分成多个项目之后，引发的沟通协作问题。





#### 技术上的痛点：巨石应用，可维护性

- 代码量达到一定量的时候，单次构建时间很长，开发&发布效率极低
- 代码库中依赖升级会影响整个应用，而代码量又非常大，导致回归成本极高
- 变成一个非常臃肿的巨石应用，完全失去灵活性，无论是多人协作还是业务接入成本都会大大增加



**微前端工程价值**

1. 独立开发、独立部署；
2. 框架无关；
3. 跨业务域复用；
4. 方便功能扩展、升级；
5. 便于多人协作开发；



**微前端业务价值**

1. 业务原子化输出；
2. 业务编排整合；



#### 业务上的场景：应用的拆分和编排

- 用户端必须是「一个系统」的心智，从域名到体验
- 能够根据功能拆分成多个子应用，每个子应用独立开发独立部署
- 子应用尽量保证跟传统单页面应用一样的开发体验，不要让开发者有太多学习成本
- 所有子应用可被统一管理起来，不能无限制的泛滥







微前端具体要解决好的 10 个问题：

1. 微应用的注册、异步加载和生命周期管理；
2. 微应用之间、主从之间的消息机制；
3. 微应用之间的安全隔离措施；
4. 微应用的框架无关、版本无关；
5. 微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理；
6. 微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）；
7. 微应用的发布流程；
8. 微应用打包优化问题；
9. 微应用专有云场景的出包方案；
10. 渐进式升级：用微应用方案平滑重构老项目。





微前端的技术细节其实相对比较简单，无非就几点：

1. 样式隔离
2. window 沙箱
3. 通信机制



为了实现上面三点目标，大家使用了很多不同的机制，大概就这么几种：

1. iframe

iframe 理论上可以用来做沙箱的，无论是 js 还是 css 都可以隔离，几乎可以说什么也不用做就把一个架构理想给实现了

iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。

但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

缺点：

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..

1. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。

2. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

   

2. web-component

web component 是浏览器自带的一套 runtime，它提供 shadow dom，能够完全隔离 css

我个人认为这是最好的微前端方案，但它也有缺点：

1. 兼容问题，倒不是 ie 的兼容，而是国产浏览器很多都阉割掉了 shadow dom
2. 隔离太硬，穿透是世纪难题

上面两点，其实都不是很要紧的问题，兼容问题可以降级（polyfill），而且现在穿透隔离的方式也越来越多

与此而来的是 web component 很多优势，最主要的是它提供了一层 runtime，自带生命周期和双向绑定，可以更方便地做各种操作



**沙箱**

微前端的沙箱和其他地方的沙箱不太一样，微前端的沙箱是指的 window

大概有两种方案，一种是通过来回遍历的方式实现的「快照沙箱」，一种是使用 proxy 实现的「劫持沙箱」

更加推荐 proxy ，因为可以多个应用 new 多个 Proxy







 iframe 作为子应用的一些劣势：

- 使用iframe 会大幅增加内存和计算资源，因为 iframe 内所承载的页面需要一个全新并且完整的文档环境
- iframe 与上层应用并非同一个文档上下文导致
- 主应用劫持快捷键操作
- 事件无法冒泡顶层，针对整个应用统一处理时效
- 事件冒泡不穿透到主文档树上，焦点在子应用时，事件无法传递上一个文档流
- 跳转路径无法与上层文档同步，刷新丢失路由状态
- iframe 内元素会被限制在文档树中，视窗宽高限制问题
- iframe 登录态无法共享，子应用需要重新登录
- iframe 在禁用三方 cookie 时，iframe 平台服务不可用
- iframe 应用加载失败，内容发生错误主应用无法感知
- 难以计算出 iframe 作为页面一部分时的性能情况
- 无法预加载缓存 iframe 内容
- 无法共享基础库进一步减少包体积
- 事件通信繁琐且限制多














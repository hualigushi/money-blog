[如何减少浏览器repaint和reflow（上](https://blog.csdn.net/baiduforum/article/details/5415527)


[如何减少浏览器repaint和reflow（中](https://blog.csdn.net/baiduforum/article/details/5416337)


[如何减少浏览器repaint和reflow（下）](https://blog.csdn.net/baiduforum/article/details/5416352)




[前端性能优化指南](https://zhuanlan.zhihu.com/p/88384957)

[前端优化之网络请求](https://www.jianshu.com/p/319249e0d1af)



Web 性能包括站在**开发者视角**的**可客观度量的性能**和站在**用户视角**的**主观的可感知的性能**。



## 🎯 客观性能

对于开发者来说，我们更加关注加载时间、可交互时间和每秒帧数(FPS)等等（更多的衡量指标在后面专门介绍），这些都是可以客观度量的，我们可以通过一些手段来优化 Web 性能，使这些度量指标达到开发者设定的标准。例如：

- **减少加载时间**：页面**正常加载**过程中所需的文件需要多长时间才能下载到用户的计算机上，这往往会受到网络、文件大小、文件数量以及其他因素的影响。一般策略是使文件尽可能小，尽可能减少HTTP请求的数量，或采用**预加载**策略提前加载使文件更快地可用。
- **使网站尽快可用**：我们可以以合理的顺序加载网站资源，以便用户能够真正快速地开始使用。当用户执行主要任务时，任何其他资源都可以放在后台继续加载，或者只在实际需要时加载资源，即**延迟加载**。例如当访问页面时可以优先加载首屏需要的资源，其他资源可以延迟加载。
- **平滑性和交互性**：在让应用程序感觉流畅方面有很多最佳实践，例如使用 CSS 动画而不是 JavaScript 来制作动画，以及最小化由于 DOM 的更改而导致UI需要的重绘次数。

**客观性能是从发出请求开始，到下载、解析和执行所有资源以及最终绘制的整个过程的时间度量。**


## 🍭 感知性能

而对于用户来说，用户的**感知性能**才是最重要的。感知性能是基于加载时间和页面响应性的一个主观指标，衡量一个网站在用户看来有多快，即当网站加载到足以让用户相信它已经加载完毕并且可交互的时候。

感知性能是用户的视角，而不是衡量标准。有一些前端优化技术可以提高可感知的性能，让文档内容能更快的呈现。例如：

- 向脚本添加 defer 或 async 属性，或者将脚本放在文档的末尾；
- 将 CSS 放在文档的头部和提前加载字体文件，可以防止页面闪动；
- 只加载首屏需要的资源，延迟加载首屏不需要的资源；

即使一个页面加载或一个操作响应需要很长时间，也可以通过一些方式让用户觉得没有那么慢。例如：

- 在页面加载过程中展示**打底图**，从打底图到内容渲染完成的过程是相对连贯的过程，用户不会因为等待而焦躁；
- 在页面加载或数据请求过程中展示加载信息或**加载动画**；
- 在上传文件、解析数据等交互场景时展示**进度条；**


显示内容，或者至少显示页面的某个部分，并指示内容正在尽快加载，对于提高感知性能至关重要。当页面客观性能难以优化时，这些方式可以让用户感知的性能比页面的实际性能更好，这也是优化 Web 性能的一种方式。通俗点说，**你的页面可能不能做得更快，但你可以让用户感觉更快。**



在难以优化客观性能时，可以通过一些方式提升用户的感知性能，这是提升用户体验的一种方式, Web 性能是属于用户体验的一部分。另外，用户体验除了良好的网站性能，还包括友好的异常处理、容错降级策略、无障碍能力、视觉体验、交互体验等等。



度量性能 window.performance 

PWA   requestIdleCallback   IntersectionObserver   MutationObserver

图片 loading 属性

缓存优化    IndexDB，HTTP/2 或 Service Workers 





### Page Visibility 

此规范提供了观察页面可见性状态的 API ，例如当用户最小化窗口或切换到另一个选项卡时，API 会发送[visibilitychange](https://developer.mozilla.org/zh-CN/docs/Web/Reference/Events/visibilitychange) 事件，让监听者知道页面状态已更改，我们可以检测事件并执行某些操作。

例如网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片；显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。

因此，**页面可见性 API** 对于**节省资源**和**提高性能**特别有用，它使页面在文档不可见时避免执行不必要的任务。


 document.visibilityState 访问页面可见状态

可通过 visibilitychange 事件监听页面可见状态是否有改变，如果有改变通过 document.visibilityState 获取页面改变后的状态。









webpack-bundle-analyzer（可视化视图查看器）





##### 性能优化方案有哪些

```
可以从减少资源体积和减少请求次数两个方向展开，另外可以考虑升级http协议版本，使用异步加载非核心资源或使用预加载。  

其中减少资源体积可以通过gzip压缩，对图片进行压缩，使用webp图片格式，优化编译后代码体积等方式展开。   

减少请求次数，可以通过DNS预解析，浏览器缓存，CDN等方式展开。  
```





减少http请求、压缩合并js以及css、图片懒加载的技术、防止回流和重绘、css放头部、js放底部。

以上的说法对吗？完全正确！可是在这个过程中，我觉得缺少一种思考。

比如减少http请求，可以从哪些纬度上减少呢？比如合并http请求？比如合并资源？比如图片懒加载？http还有其他纬度的优化吗？cookie优化？http请求和资源加载的区分优化？在webview中呢？和普通的浏览器的优化技术，又有什么区别？




server：

使用 cdn
减少不必要的数据返回
使用 gzip
缓存 （etag / expires ...）

content：

减少 http 请求 (css sprites / inline image)
不同资源放在不同域下 (http1.1)
延迟加载 / 延迟执行(立即下载，延迟执行[before DOMContentLoaded]defer) / 预加载(preload)

async，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有 src 属性的脚本）。
defer，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行。


精简 HTML 结构
压缩资源

css:

in head
较少的层级（之前被问到过是否有统计过层级多与少对性能的实质影响，实际上我是没有做过此类研究，所以知道结论而不懂过程还是欠缺的）

js:

before 
减少 dom 访问（在 body 内放置的 JS 代码是否可以访问到 body 标签）

webpack:

tree shaking 去除没有使用的代码
提取公共包，有被问到
拆分模块，按需加载
优化图片，使用 base64 代替小图
file name with hash (etag)



## 项目性能优化

### 1. 编码优化

编码优化，指的就是 在代码编写时的，通过一些 **最佳实践**，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于 **程序猿的自我修养**，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。

- **数据读取**:
  - 通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；
  - 对象嵌套越深，读取值也越慢；
  - **最佳实践**
    - 尽量在局部作用域中进行 **变量缓存**；
    - 避免嵌套过深的数据结构，**数据扁平化** 有利于数据的读取和维护；
- **循环**: 循环通常是编码性能的关键点；
  - 代码的性能问题会再循环中被指数倍放大；
  - **最佳实践**
    - 尽可能**减少循环次数**
      - 减少遍历的数据量；
      - 完成目的后马上结束循环；
    - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
    - js 中使用 **倒序循环** 会略微提升性能；
    - 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；
- **条件流程性能**: Map / Object > switch > if-else

```
// 使用 if-else
if(type === 1) {

} else if (type === 2) {

} else if (type === 3) {

}

// 使用 switch
switch (type) {
	case 1:
		break;4
	case 2:
		break;
	case 3:
		break;
    default:
        break;
}

// 使用 Map
const map = new Map([
	[1, () => {}],
	[2, () => {}],
	[3, () => {}],
])
map.get(type)()

// 使用 Objext
const obj = {
	1: () => {},
	2: () => {},
	3: () => {},
}
obj[type]()
```

- **减少 cookie 体积**: 能有效减少每次请求的体积和响应时间；

  - 去除不必要的 cookie；
  - 压缩 cookie 大小；
  - 设置 domain 与 过期时间；

- **dom 优化**:

  - **减少访问 dom 的次数**，如需多次，将 dom 缓存于变量中；
  - **减少重绘与回流**
    - 多次操作合并为一次；
    - 减少对计算属性的访问；
      - 例如 offsetTop， getComputedStyle 等
      - 因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；
    - 大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
    - 使用`DocumentFragment / cloneNode / replaceChild`进行操作；
  - 使用事件委托，避免大量的事件绑定；

- **css 优化**:

  - **层级扁平**，避免过于多层级的选择器嵌套；
  - **特定的选择器** 好过一层一层查找: .xxx-child-text{} 优于 .xxx .child .text{}
  - **减少使用通配符与属性选择器**；
  - **减少不必要的多余属性**；
  - 使用 **动画属性** 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
  - 使用 `link` 替代原生 @import；

- **html 优化**:

  - **减少 dom 数量**，避免不必要的节点或嵌套；

  - 避免`<img src="" />`空标签

    ，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

    - IE 向页面所在的目录发送请求；
    - Safari、Chrome、Firefox 向页面本身发送请求；
    - Opera 不执行任何操作。

  - 图片提前 **指定宽高** 或者 **脱离文档流**，能有效减少因图片加载导致的页面回流；

  - **语义化标签** 有利于 SEO 与浏览器的解析时间；

  - 减少使用 table 进行布局，避免使用`<br/>` `与`<hr/>`；

### 2. 页面基础优化

- **引入位置**: css 文件`<head>`中引入， js 文件`<body>`底部引入；
  - 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；
- **减少请求** (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
- **减少文件体积**
  - **删除多余代码**
    - tree-shaking
    - UglifyJs
    - code-spliting
  - **混淆 / 压缩代码**，开启 gzip 压缩；
  - **多份编译文件按条件引入**
    - 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
    - 可以利用` / <script type="module">`进行条件引入用
  - **动态 polyfill**，只针对不支持的浏览器引入 polyfill；
- **图片优化**
  - 根据业务场景，与UI探讨选择 **合适质量，合适尺寸**；
  - 根据需求和平台，选择 **合适格式**，例如非透明时可用 jpg；非苹果端，使用 webp；
  - 小图片合成 **雪碧图**，低于 5K 的图片可以转换成 **base64** 内嵌；
  - 合适场景下，使用 **iconfont** 或者 **svg**；
- **使用缓存**
  - **浏览器缓存**: 通过设置请求的过期时间，合理运用浏览器缓存；
  - **CDN缓存**: 静态文件合理使用 CDN 缓存技术；
    - HTML 放于自己的服务器上；
    - 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
    - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；
  - **服务器缓存**: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
  - **数据缓存**: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

### 3. 首屏渲染优化

- **css / js 分割**，使首屏依赖的文件体积最小，内联首屏关键 css / js；
- 非关键性的文件尽可能的 **异步加载和懒加载**，避免阻塞首页渲染；
- 使用`dns-prefetch / preconnect / prefetch / preload`等浏览器提供的资源提示，加快文件传输；
- 谨慎控制好**Web字体**，一个大字体包足够让你功亏一篑；
  - 控制字体包的加载时机；
  - 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；
- 合理利用 Localstorage / server-worker 等存储方式进行 **数据与资源缓存**；
- **分清轻重缓急**
  - 重要的元素优先渲染；
  - 视窗内的元素优先渲染；
- **服务端渲染(SSR)**
  - 减少首屏需要的数据量，剔除冗余数据和请求；
  - 控制好缓存，对数据/页面进行合理的缓存；
  - 页面的请求使用流的形式进行传递；
- **优化用户感知**
  - 利用一些动画 **过渡效果**，能有效减少用户对卡顿的感知；
  - 尽可能利用 **骨架屏(Placeholder) / Loading** 等减少用户对白屏的感知；
  - 动画帧数尽量保证在 **30帧** 以上，低帧数、卡顿的动画宁愿不要；
  - js 执行时间避免超过**100ms**，超过的话就需要做:
    - 寻找可 缓存 的点；
    - 任务的 分割异步 或 web worker 执行；
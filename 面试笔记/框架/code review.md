# code review常规项目

代码是否符合公共的编程规范？包括变量名，函数名，缩进，格式和注释。

是否有被注释掉的代码或者调试代码？

代码书写是否简单明了？

是否存在多余的或是重复的代码？

代码是否尽可能的模块化？

循环是否设置了长度和正确的终止条件？

是否有可以被库函数替代的代码？

是否进行异常处理？

是否有更好的处理方法？

有没有遗漏任何corner case?

文件组织，函数是不是应该放到其他lib或库中？

是否应该使用继承保持风格统一?

线程是否安全？

是否可以使用更好的设计模式？

扩展性是否良好？




# 如何迅速完成CodeReview？

#### 1.不要刻意地去寻找代码bug

  - 有些代码的逻辑是比较复杂的，如果是很容易就发现的缺陷，大多数情况下评审者自己在编码过程就会发现，
  
    那么剩下不容易发现的缺陷要发现也会花费较多的时间，这些问题可以交给测试人员去发现；
  - 如果参与者刻意去找bug会造成顾此失彼，忽略更重要的东西；当然，有些bug你可能一眼就看出来了，那提出来就再好不过了。

#### 2.不要按照自己的编程风格去评论别人的代码

  - 有些人参与者比较自信，对自己写得代码感觉很满意，所以有时候就会根据自己熟悉的编码语言或者编码风格去评论别人的代码；
  - 作为参与者，只要觉得评审者的代码符合命名要求和设计要求就可以了，但假如评审者的代码缺陷很明显，可以提出带大家进行讨论。

#### 3.不要带着抨击和质疑别人能力的心态去进行代码评审

  - 有时候参与者可能心情不好，或者感觉对方是新人就忍不住会抨击对方的代码，这样会比较容易在模棱两可的问题上浪费时间；
  - 参与者可能认为A方法好，评审者可能认为B方法也不坏，这样就会造成没有必要的争论而浪费时间。

#### 4.不要在不确定的问题上争来争去

  - 大家在讨论的时候如果某些问题讨论一段时间以后仍然没有结论，或者需要第三方确认或者评审者不能马上理解参与者提出的意见时，不要花太多时间讨论这些问题；
  - 把这些问题先记录下来，等会议结束后评审者可以与参与者进行线下讨论，同时将这些问题根据自己的理解进行解决，之后给大家一个反馈即可，这样可以节省很多时间。

#### 5.不要听不进别人的意见

  - 有些评审者比较固执，不愿意接受大家的意见，会造成一些不必要的争端和讨论，浪费时间；
  - 当然，有时候参与者的意见不见得是最好的，作为评审者将其作为一个参照的方向和视角，如果存在争论，这些建议也可以做成会议记录，评审者私下和建议提出者讨论以后给大家一个结论。

#### 6.参与者最好不要自己都没想明白就提意见

  - 如果参与者自己没有想明白的事情就去提意见，那么评审者反问的时候会浪费大家的时间；
  - 参与者可以先将自己的想法大致记下来，自己想清楚了之后再提给评审者也是节省时间的办法。

#### 7.评审前最好先通过代码静态检查工具检测

 - 一般规范性的问题都可以通过静态检测工具发现，借助工具是最省事，也是效率最高的，还可以避免大家都评审时提出很多规范性问题，而遗漏了业务逻辑、设计合理性等问题。



# Code Review 需要做什么

Code Review主要检查代码中是否存在以下方面问题：

代码的一致性、编码风格、代码的安全问题、代码冗余、是否正确设计以满足需求（性能、功能）等等

### 2.1 完整性检查（Completeness）
  - 代码是否完全实现了设计文档中提出的功能需求
  - 代码是否已按照设计文档进行了集成和Debug
  - 代码是否已创建了需要的数据库，包括正确的初始化数据
  - 代码中是否存在任何没有定义或没有引用到的变量、常数或数据类型

### 2.2 一致性检查（Consistency）
  - 代码的逻辑是否符合设计文档
  - 代码中使用的格式、符号、结构等风格是否保持一致

### 2.3 正确性检查（Correctness）
  - 代码是否符合制定的标准
  - 所有的变量都被正确定义和使用
  - 所有的注释都是准确的
  - 所有的程序调用都使用了正确的参数个数

### 2.4 可修改性检查（Modifiability）
  - 代码涉及到的常量是否易于修改(如使用配置、定义为类常量、使用专门的常量类等)
  - 代码中是否包含了交叉说明或数据字典，以描述程序是如何对变量和常量进行访问的
  - 代码是否只有一个出口和一个入口（严重的异常处理除外）

### 2.5 可预测性检查（Predictability）
  - 代码所用的开发语言是否具有定义良好的语法和语义
  - 是否代码避免了依赖于开发语言缺省提供的功能
  - 代码是否无意中陷入了死循环
  - 代码是否是否避免了无穷递归

### 2.6 健壮性检查（Robustness）
  - 代码是否采取措施避免运行时错误（如数组边界溢出、被零除、值越界、堆栈溢出等）
  - Error handling是否都处理完毕(例如空指针检查、应该catch哪些异常)

### 2.7 结构性检查（Structuredness）
  - 程序的每个功能是否都作为一个可辩识的代码块存在
  - 循环是否只有一个入口

### 2.8 可追溯性检查（Traceability）
  - 代码是否对每个程序进行了唯一标识
  - 是否有一个交叉引用的框架可以用来在代码和开发文档之间相互对应
  - 代码是否包括一个修订历史记录，记录中对代码的修改和原因都有记录
  - 是否所有的安全功能都有标识

### 2.9 可理解性检查（Understandability）
  - 注释是否足够清晰的描述每个子程序
  - 是否使用到不明确或不必要的复杂代码，它们是否被清楚的注释
  - 使用一些统一的格式化技巧（如缩进、空白等）用来增强代码的清晰度
  - 是否在定义命名规则时采用了便于记忆，反映类型等方法
  - 每个变量都定义了合法的取值范围
  - 代码中的算法是否符合开发文档中描述的数学模型

### 2.10可验证性检查(Verifiability)
  - 代码中的实现技术是否便于测试

### 2.11 效率
  - 代码效率包括读代码的效率与执行代码的效率，如何尽量减小算法复杂度、减少临时对象等等。

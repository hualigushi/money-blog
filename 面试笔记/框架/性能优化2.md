--------------2021-06-12-----------------

1. 懒加载  IntersectionObserver

   用于图片懒加载  模块懒加载   展示日志上报   滚动到底部加载更多

2. 节流  防抖

3. 打包优化

   code spliting

4. 预加载  实现成本最低 最高效

   `<link rel="preconnect" href="">`

   - preconnect

     作用：提前建立好TCP连接

     使用场景：静态资源的CDN域名，跨域请求的域名

   - proload

     作用：高优先级预加载资源，适用于本页面用到的资源

     使用场景：需要在首屏展示的关键图片，动态加载模块(code-spliting)对应的资源

   - prefetch

   ​       作用：低优先级预加载资源，适用于下一个页面将要用到的资源

   ​       使用场景：提前请求下一个页面及其资源，如果预加载的对象是一个页面，那这个页面应该返回相应的表示可缓存的响应头

   - prerendering

     作用：与Prefetch相似，prerendering更适用于页面，预加载时，同时也会预加载页面里的资源

     使用场景： 流量开销比较大，适用于明确知道用户会进入某个页面

5. SSR

​      注意：

​          不能使用全局变量

​          要时刻注意内存泄漏问题

​          代码里不能使用window  document  process,如果第三方库用

​          了window变量，需要用webpack exclude掉  或者alias到一个

​           空文件夹上

6. PWA



----------------------------------------------------



##### 工程化方向

1. 客户端Gzip离线包，服务器资源Gzip压缩。
2. JS瘦身，Tree shaking，ES Module，动态Import，动态Polyfill。
3. 图片加载优化，Webp，考虑兼容性，可以提前加载一张图片，嗅探是否支持Webp。
4. 延迟加载不用长内容。通过打点，看某些弹窗内或者子内容是否要初始化加载。
5. 服务端渲染，客户端预渲染。
6. CDN静态资源
7. Webpack Dll，通用优先打包抽离，利用浏览器缓存。
8. 骨架图
9. 数据预取，包括接口数据，和加载详情页图片。
10. Webpack本身提供的优化，Base64，资源压缩，Tree shaking，拆包chunk。
11. 减少重定向。


 







 




 



 



度量性能 window.performance 

PWA   requestIdleCallback   IntersectionObserver   MutationObserver

图片 loading 属性

缓存优化    IndexDB，HTTP/2 或 Service Workers 





### Page Visibility 

此规范提供了观察页面可见性状态的 API ，例如当用户最小化窗口或切换到另一个选项卡时，API 会发送[visibilitychange](https://developer.mozilla.org/zh-CN/docs/Web/Reference/Events/visibilitychange) 事件，让监听者知道页面状态已更改，我们可以检测事件并执行某些操作。

例如网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片；显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。

因此，**页面可见性 API** 对于**节省资源**和**提高性能**特别有用，它使页面在文档不可见时避免执行不必要的任务。


 document.visibilityState 访问页面可见状态

可通过 visibilitychange 事件监听页面可见状态是否有改变，如果有改变通过 document.visibilityState 获取页面改变后的状态。









webpack-bundle-analyzer（可视化视图查看器）





##### 性能优化方案有哪些

```
可以从减少资源体积和减少请求次数两个方向展开，另外可以考虑升级http协议版本，使用异步加载非核心资源或使用预加载。  

其中减少资源体积可以通过gzip压缩，对图片进行压缩，使用webp图片格式，优化编译后代码体积等方式展开。   

减少请求次数，可以通过DNS预解析，浏览器缓存，CDN等方式展开。  
```





减少http请求、压缩合并js以及css、图片懒加载的技术、防止回流和重绘、css放头部、js放底部。

以上的说法对吗？完全正确！可是在这个过程中，我觉得缺少一种思考。

比如减少http请求，可以从哪些纬度上减少呢？比如合并http请求？比如合并资源？比如图片懒加载？http还有其他纬度的优化吗？cookie优化？http请求和资源加载的区分优化？在webview中呢？和普通的浏览器的优化技术，又有什么区别？




server：

使用 cdn
减少不必要的数据返回
使用 gzip
缓存 （etag / expires ...）

content：

减少 http 请求 (css sprites / inline image)
不同资源放在不同域下 (http1.1)
延迟加载 / 延迟执行(立即下载，延迟执行[before DOMContentLoaded]defer) / 预加载(preload)

async，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有 src 属性的脚本）。
defer，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行。


精简 HTML 结构
压缩资源

css:

in head
较少的层级（之前被问到过是否有统计过层级多与少对性能的实质影响，实际上我是没有做过此类研究，所以知道结论而不懂过程还是欠缺的）

js:

before 
减少 dom 访问（在 body 内放置的 JS 代码是否可以访问到 body 标签）

webpack:

tree shaking 去除没有使用的代码
提取公共包，有被问到
拆分模块，按需加载
优化图片，使用 base64 代替小图
file name with hash (etag)



## 项目性能优化

### 1. 编码优化

编码优化，指的就是 在代码编写时的，通过一些 **最佳实践**，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于 **程序猿的自我修养**，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。

- **数据读取**:
  - 通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；
  - 对象嵌套越深，读取值也越慢；
  - **最佳实践**
    - 尽量在局部作用域中进行 **变量缓存**；
    - 避免嵌套过深的数据结构，**数据扁平化** 有利于数据的读取和维护；
- **循环**: 循环通常是编码性能的关键点；
  - 代码的性能问题会再循环中被指数倍放大；
  - **最佳实践**
    - 尽可能**减少循环次数**
      - 减少遍历的数据量；
      - 完成目的后马上结束循环；
    - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
    - js 中使用 **倒序循环** 会略微提升性能；
    - 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；
- **条件流程性能**: Map / Object > switch > if-else

```
// 使用 if-else
if(type === 1) {

} else if (type === 2) {

} else if (type === 3) {

}

// 使用 switch
switch (type) {
	case 1:
		break;4
	case 2:
		break;
	case 3:
		break;
    default:
        break;
}

// 使用 Map
const map = new Map([
	[1, () => {}],
	[2, () => {}],
	[3, () => {}],
])
map.get(type)()

// 使用 Objext
const obj = {
	1: () => {},
	2: () => {},
	3: () => {},
}
obj[type]()
```

- **减少 cookie 体积**: 能有效减少每次请求的体积和响应时间；

  - 去除不必要的 cookie；
  - 压缩 cookie 大小；
  - 设置 domain 与 过期时间；

- **dom 优化**:

  - **减少访问 dom 的次数**，如需多次，将 dom 缓存于变量中；
  - **减少重绘与回流**
    - 多次操作合并为一次；
    - 减少对计算属性的访问；
      - 例如 offsetTop， getComputedStyle 等
      - 因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；
    - 大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
    - 使用`DocumentFragment / cloneNode / replaceChild`进行操作；
  - 使用事件委托，避免大量的事件绑定；

- **css 优化**:

  - **层级扁平**，避免过于多层级的选择器嵌套；
  - **特定的选择器** 好过一层一层查找: .xxx-child-text{} 优于 .xxx .child .text{}
  - **减少使用通配符与属性选择器**；
  - **减少不必要的多余属性**；
  - 使用 **动画属性** 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
  - 使用 `link` 替代原生 @import；

- **html 优化**:

  - **减少 dom 数量**，避免不必要的节点或嵌套；

  - 避免`<img src="" />`空标签

    ，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

    - IE 向页面所在的目录发送请求；
    - Safari、Chrome、Firefox 向页面本身发送请求；
    - Opera 不执行任何操作。

  - 图片提前 **指定宽高** 或者 **脱离文档流**，能有效减少因图片加载导致的页面回流；

  - **语义化标签** 有利于 SEO 与浏览器的解析时间；

  - 减少使用 table 进行布局，避免使用`<br/>` `与`<hr/>`；

### 2. 页面基础优化

- **引入位置**: css 文件`<head>`中引入， js 文件`<body>`底部引入；
  - 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；
- **减少请求** (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
- **减少文件体积**
  - **删除多余代码**
    - tree-shaking
    - UglifyJs
    - code-spliting
  - **混淆 / 压缩代码**，开启 gzip 压缩；
  - **多份编译文件按条件引入**
    - 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
    - 可以利用` / <script type="module">`进行条件引入用
  - **动态 polyfill**，只针对不支持的浏览器引入 polyfill；
- **图片优化**
  - 根据业务场景，与UI探讨选择 **合适质量，合适尺寸**；
  - 根据需求和平台，选择 **合适格式**，例如非透明时可用 jpg；非苹果端，使用 webp；
  - 小图片合成 **雪碧图**，低于 5K 的图片可以转换成 **base64** 内嵌；
  - 合适场景下，使用 **iconfont** 或者 **svg**；
- **使用缓存**
  - **浏览器缓存**: 通过设置请求的过期时间，合理运用浏览器缓存；
  - **CDN缓存**: 静态文件合理使用 CDN 缓存技术；
    - HTML 放于自己的服务器上；
    - 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
    - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；
  - **服务器缓存**: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
  - **数据缓存**: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

### 3. 首屏渲染优化

- **css / js 分割**，使首屏依赖的文件体积最小，内联首屏关键 css / js；
- 非关键性的文件尽可能的 **异步加载和懒加载**，避免阻塞首页渲染；
- 使用`dns-prefetch / preconnect / prefetch / preload`等浏览器提供的资源提示，加快文件传输；
- 谨慎控制好**Web字体**，一个大字体包足够让你功亏一篑；
  - 控制字体包的加载时机；
  - 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；
- 合理利用 Localstorage / server-worker 等存储方式进行 **数据与资源缓存**；
- **分清轻重缓急**
  - 重要的元素优先渲染；
  - 视窗内的元素优先渲染；
- **服务端渲染(SSR)**
  - 减少首屏需要的数据量，剔除冗余数据和请求；
  - 控制好缓存，对数据/页面进行合理的缓存；
  - 页面的请求使用流的形式进行传递；
- **优化用户感知**
  - 利用一些动画 **过渡效果**，能有效减少用户对卡顿的感知；
  - 尽可能利用 **骨架屏(Placeholder) / Loading** 等减少用户对白屏的感知；
  - 动画帧数尽量保证在 **30帧** 以上，低帧数、卡顿的动画宁愿不要；
  - js 执行时间避免超过**100ms**，超过的话就需要做:
    - 寻找可 缓存 的点；
    - 任务的 分割异步 或 web worker 执行；
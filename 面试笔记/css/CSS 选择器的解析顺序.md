CSS选择器是**从右往左解析**的

若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。

若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找父节点直到找到根元素或者满足条件的匹配规则，则结束这个分支的遍历。

两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。



举例说明：

```css
.mod-nav h3 span { font-size: 16px; }
```

为什么从右向左的规则要比从左向右的高效？![图片](https://mmbiz.qpic.cn/mmbiz_png/UAyibZfx5saXrdWfpmjhBWaVHic27e24sywQiaGGY4xegtwbPgCywzrnky8n2TicPp5yT7fmLibmOQvclMRiaAUmNuFA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

若从左向右的匹配，过程是：从`.mod-nav`开始，遍历子节点`header`和子节点`div`，然后各自向子节点遍历。在右侧`div`的分支中，最后遍历到叶子节点`a`，发现不符合规则，需要回溯到`ul`节点，再遍历下一个`li-a`，假如有1000个`li`，则这`1000`次的遍历与回溯会损失很多性能。

再看看从右至左的匹配：先找到所有的最右节点span，对于每一个`span`，向上寻找节点`h3`，由`h3`再向上寻找`class=mod-nav`的节点，最后找到根元素html则结束这个分支的遍历。

很明显，两种匹配规则的性能差别很大。之所以会差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。
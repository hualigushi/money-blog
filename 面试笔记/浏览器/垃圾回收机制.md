## 含义

**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

```
function fn1() {
 var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
 var obj = {name:'hanzichi', age: 10};
 return obj;
}
var a = fn1();
var b = fn2();
```

首先声明了两个函数，分别叫做 fn1 和 fn2，当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象 	{name: 'hanzichi', age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被 JS 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放



## 标记清除

流程：

　　1.浏览器再运行的时候会给存储再内存中的所有变量都加上标记

　　2.去掉环境中的变量以及被环境中引用的变量的标记

　　3.如果还有变量有标记，就会被视为准备删除的变量

　　4.垃圾回收机制完成内存的清除工作，销毁那些带标记的变量，并回收他们所占用的内存空间



## 什么时候触发垃圾回收
一般浏览器会自动触发 GC，当触发 GC 的时候，浏览器就会停止工作。如果频繁触发 GC 页面就会发生抖动现象。

一般的 GC 耗时在 100ms 左右，对于一般的程序来说够了。但是对于一些流畅度要求高的程序来说就很麻烦，这就需要新引擎需要优化的地方。


## GC方案

#### 基础方案

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。

在`64`位系统下，V8最多只能分配`1.4G`, 在 32 位系统中，最多只能分配`0.7G`。

对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了.



#### GC的缺陷

GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

> 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上。

可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是**限制堆内存**，也算是一种权衡的手段



#### GC优化策略

1. **分代回收**（Generation GC） V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：

![浏览器垃圾回收机制与 Vue 项目内存泄漏分析](http://p3.pstatp.com/large/pgc-image/3fe649e46a63419fbd17ef5b699b4ecb)



> 这里需要补充的是：对于 tenured generation 对象，有额外的开销：把它从 young generation 迁移到       tenured generation，另外，如果被引用了，那引用的指向也需要修改。

2. **增量GC** 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![浏览器垃圾回收机制与 Vue 项目内存泄漏分析](http://p3.pstatp.com/large/pgc-image/be21b45d125b40adb1bd3ebb4c40381f)



> 这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。



## chrome 的 GC 优化
V8 引擎的垃圾回收策略主要基于分代垃圾回收机制：

- 将整个堆内存分为新生代内存和老龄代内存，所有的内存分配操作发生在新生代

- 新生代内存又分成两部分，From（使用） 空间和 To（闲置） 空间，所有的内存分配操作发生在 From 空间

- 新生代空间发生 GC（复制算法）

  - 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可

  - 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色`对调`，From现在被闲置，To为正在使用，如此循环。
  - 如果某个对象已经经历过一次复制算法（**Scavenge算法**），就将该对象复制到老龄代空间
  - 如果 To 空间的使用率超过了 25%，将整个空间的对象复制到老龄代空间。主要是为了角色转换之后留足分配内存的空间



**复制的原因**

在To内存中按照顺序从头放置的，这是为了应对这样的场景:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b73ac9e01cc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做**内存碎片**。刚刚介绍的新生代垃圾回收算法也叫**Scavenge算法**。

Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7741afdb10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



大大方便了后续连续空间的分配。

不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象`一般很少`，因此`时间`性能非常优秀。





- 老龄代空间发生 GC （标记清除与标记合并）

  - 主要采用标记清除算法，通过标记清除算法清理未存活的对象
  - 清除算法完成之后会使内存空间出现不连续的状态，这种内存碎片会对后续的内存分配造成问题。因此在内存空间不足的时候采用标记合并算法，将活着的对象移动到内存的一端，完成之后清除另外一端的对象

  ​       V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

  ​      由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。

- 新生代的 GC 触发要比老龄代的频繁

- 一般浏览器要求最高 60fps，算下来每帧 16.6ms。Chrome 为了缩短 GC 时间，它尝试将工作分摊到每个空闲时间。它将检查每个帧时间（16.6 ms）的剩余时间，并尝试为 GC 做一些工作

  - 如果垃圾收集事件可能很快发生，V8 GC 将检查每 n 个分配或 m 个时间单位。V8 GC 在任务调度程序中为事件注册空闲任务。
  - 任务调度程序将调度空闲任务并使用可用空闲时间调用给定的回调。V8 GC 将检查任务是否仍处于待处理状态，以及是否有足够的空闲时间来处理任务。



**增量标记**

由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。

经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。
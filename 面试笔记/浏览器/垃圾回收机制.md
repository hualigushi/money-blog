# 内存生命周期

1. 内存分配：声明变量，函数，对象的时候，js会自动分配内存
2. 内存使用
3. 内存回收



#  垃圾回收机制

1. 引用计数垃圾回收

   会有循环引用的问题

2. 标记清除算法

   - 在运行的时候给存储在内存额所有变量加上标记
   - 从根部触发，能触及的对象，把标记清除
   - 那些有标记的就被是为即将删除的变量



# chrome 的 GC 优化

V8 引擎的垃圾回收策略主要基于分代垃圾回收机制：

- 将整个堆内存分为新生代内存和老龄代内存，所有的内存分配操作发生在新生代

- 新生代内存又分成两部分，From（使用） 空间和 To（闲置） 空间，所有的内存分配操作发生在 From 空间

- 新生代空间发生 GC（复制算法）

  - 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可

  - 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色`对调`，From现在被闲置，To为正在使用，如此循环。
  - 如果某个对象已经经历过一次复制算法（**Scavenge算法**），就将该对象复制到老龄代空间
  - 如果 To 空间的使用率超过了 25%，将整个空间的对象复制到老龄代空间。主要是为了角色转换之后留足分配内存的空间



**复制的原因**

在To内存中按照顺序从头放置的，这是为了应对这样的场景:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b73ac9e01cc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做**内存碎片**。刚刚介绍的新生代垃圾回收算法也叫**Scavenge算法**。

Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7741afdb10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



大大方便了后续连续空间的分配。

不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象`一般很少`，因此`时间`性能非常优秀。





- 老龄代空间发生 GC （标记清除与标记合并）

  - 主要采用标记清除算法，通过标记清除算法清理未存活的对象
  - 清除算法完成之后会使内存空间出现不连续的状态，这种内存碎片会对后续的内存分配造成问题。因此在内存空间不足的时候采用标记合并算法，将活着的对象移动到内存的一端，完成之后清除另外一端的对象

  ​       V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

  ​      由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。

- 新生代的 GC 触发要比老龄代的频繁

- 一般浏览器要求最高 60fps，算下来每帧 16.6ms。Chrome 为了缩短 GC 时间，它尝试将工作分摊到每个空闲时间。它将检查每个帧时间（16.6 ms）的剩余时间，并尝试为 GC 做一些工作

  - 如果垃圾收集事件可能很快发生，V8 GC 将检查每 n 个分配或 m 个时间单位。V8 GC 在任务调度程序中为事件注册空闲任务。
  - 任务调度程序将调度空闲任务并使用可用空闲时间调用给定的回调。V8 GC 将检查任务是否仍处于待处理状态，以及是否有足够的空闲时间来处理任务。



**增量标记**

由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。

那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。

经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。
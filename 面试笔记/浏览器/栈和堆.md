#### 1.从定义和存取方式上说:

- 栈stack为自动分配的内存空间, 它由系统自动释放, 特点是"LIFO，即后进先出（Last in, first out）"。数据存储时只能从顶部逐个存入，取出时也需从顶部逐个取出,js的基本数据类型(Undefined、Null、Boolean、Number和String). 基本类型在内存中占据空间小、大小固定 ，他们的值保存在栈空间，按值访问
- 堆heap是动态分配的内存，大小不定也不会自动释放. 特点是"无序"的key-value"键值对"存储方式. 比如js的对象,数组. 引用类型占据空间大、大小不固定, 栈内存中存放地址指向堆(heap)内存中的对象。是按引用访问的

#### 2.从js数据的存取过程上说:

栈内存中存放的是对象的访问地址，在堆内存中为这个值分配空间。这个值大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。这样，当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值。

#### 3.栈内存和堆内存与垃圾回收机制的联系和清除方式:

- 垃圾回收机制: JavaScript中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁。开发者也可在代码中手动设置变量值为null（xxx = null）进行清除，让引用链断开，以便下一次垃圾回收时有效回收。其次, 函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。全局环境只有页面退出时才会出栈，解除变量引用。所以工程师们应尽量避免在全局环境中创建全局变量，如需使用，一定要在不需要时手动标记清除，将内存释放。
- 栈内存和堆内存通常与垃圾回收机制有关。之所以会区分栈内存和堆内存,目的是使程序运行时占用的内存最小。当某个方法执行时，都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；当我们创建一个对象时，对象会被保存到运行时数据区中，以便反复利用（因为对象的创建内存开销较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用，则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在循环收集的过程中回收。
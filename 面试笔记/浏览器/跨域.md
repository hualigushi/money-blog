# 定义

同源策略是指只有具有相同源的页面才能够共享数据

同源是指页面具有**相同的协议、域名、端口号**，有一项不同就不是同源。 有同源策略能够保证web网页的安全性。

DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。

XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。


跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

同源策略限制了一下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取

- DOM 和 JS 对象无法获取

- Ajax请求发送不出去

  

# 跨域的解决办法

   #### 1. jsonp跨域

最大的缺陷是**只能够实现get请求**

> 浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互,jsonp跨域本质上是通过动态script标签, 本质上也是对静态资源的访问,所以只能是get请求



#### 2. 跨域资源共享 CORS

因为是目前主流的跨域解决方案

实现的基本思想是通过自定义的HTTP头部让浏览器与服务器之间进行沟通，从而决定请求或响应应该是成功，还是失败。


对于开发者来说，CORS通信与正常的的ajsx没有差别，代码也完全一样。只要浏览器发现ajax请求跨源，就会自动在头部添加一些附加的头信息，用户也不会感知。
所以CORS通信实现的关键是服务器，只要服务器支持了CORS接口，就能够进行跨域请求。

服务器设置的字段

- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Allow-Origin
- Access-Control-Allow-Credentials
- Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。



分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求

- 请求方式为HEAD、POST 或者 GET

- http头信息不超出一下字段：`Accept`、`Accept-Language` 、 `Content-Language`、 `Last-Event-ID`、 `Content-Type`(限于三个值：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)



#### 3. WebSocket协议跨域

WebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

前端代码：

```
<div>user input：<input type="text"></div>

<script src="./socket.io.js"></script>

<script>

var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {

    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg);
    });

    // 监听服务端关闭
    socket.on('disconnect', function() {
        console.log('Server socket has closed.');
    });
});


document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

node Server

```
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');


// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.');
    });

});
```

#### 4. nginx反向代理  

- nginx反向代理，代理从客户端来的请求，转发到其代理源
- 通过配置nginx的配置文件实现代理到不同源

```
// nginx.conf配置
server {
  listen 80;  // 监听端口
  server_name  www.baidu.com; // 匹配来源
  location / {  //匹配路径
    // 反向代理到http://127.0.0.1:3000
    proxy_pass http://127.0.0.1:3000;
    // 默认入口文件
    index  index.html index.htm index.jsp;
}
```

- nginx反向代理还能实现负载均衡





#### 5. postMessage跨域

可用于不同页面之间的跨域传递数据

`postMessage(data,origin[, source])`

data为发送的数据只能发送字符串信息, 类型为String，Object(IE8、9不支持Obj)，

origin发送目标源，指定哪些窗口能接收到消息事件，如果origin设置为*则表示无限制，

source为发送消息窗口的window对象引用，

```
<!-- test.html -->
<iframe src="http://127.0.0.1:5501/postMessage.html"
name="postIframe" onload="messageLoad()"></iframe>
<script>
// 定义加载之后执行的函数，给postMessage.html发送数据
function messageLoad() {
  const url = 'http://127.0.0.1:5501/postMessage.html'
  window.postIframe.postMessage('给postMessage的数据', url)
}
// 用于监听postMessage.html的回馈，执行回调
window.addEventListener('message', (event) => {
  console.log(event.data);
})
</script>
----------------------------------------------
<!-- postMessage.html -->
<script>
  // 监听test.html发来的数据，延迟1秒返回数据
  window.addEventListener('message', (event) => {
    setTimeout(() => {
      event.source.postMessage('给test的数据', event.origin)
    },1000)
  })
</script>
```

event对象的几个重要属性

- data 指的是从其他窗口发送过来的消息对象
- type 指的是发送消息的类型
- source 指的是发送消息的窗口对象
- origin 指的是发送消息的窗口的源





# 如何减少options请求？

Access-Control-Max-Age:1800

首部字段 Access-Control-Max-Age 表明该响应的有效时间，单位是【秒】，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。

不同浏览器有不同的上限。在Firefox中，上限是24h（即86400秒），而在Chromium 中则是10min（即600秒）。Chromium 同时规定了一个默认值 5 秒。

Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。也就是说，如果设置了10分钟的缓存，在10分钟内，所有请求第一次会产生options请求，第二次以及第二次以后就只发送真正的请求了。

Access-Control-Max-Age:-1时，将禁用options请求，需要对所有呼叫进行预检选项检查。
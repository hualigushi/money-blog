# 定义

同源策略是指只有具有相同源的页面才能够共享数据

同源是指页面具有**相同的协议、域名、端口号**，有一项不同就不是同源。 有同源策略能够保证web网页的安全性。

DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。

XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。


跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

同源策略限制了一下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取

- DOM 和 JS 对象无法获取

- Ajax请求发送不出去

  

# 跨域的解决办法

   #### 1. jsonp跨域

最大的缺陷是**只能够实现get请求**



#### 2. 跨域资源共享 CORS

因为是目前主流的跨域解决方案

简介
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

$\color{red}{CORS需要浏览器和服务器同时支持}$

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求

- 请求方式为HEAD、POST 或者 GET

- http头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain)

为什么要分为简单请求和非简单请求，因为浏览器对这两种请求方式的处理方式是不同的。



- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Allow-Origin
- Access-Control-Allow-Credentials
- Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。



#### 3. WebSocket协议跨域

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

前端代码：

```
<div>user input：<input type="text"></div>

<script src="./socket.io.js"></script>

<script>

var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {

    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg);
    });

    // 监听服务端关闭
    socket.on('disconnect', function() {
        console.log('Server socket has closed.');
    });
});


document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

node Server

```
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');


// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.');
    });

});
```

#### 4. nginx代理跨域  

#### 5. postMessage跨域

这是由H5提出来的一个炫酷的API

发送信息的postMessage方法是向外界窗口发送信息

```
otherWindow.postMessage(message,targetOrigin);
```

otherWindow指的是目标窗口，也就是要给哪一个window发送消息，是window.frames属性的成员或者是window.open方法创建的窗口。 

message是要发送的消息，类型为String，Object(IE8、9不支持Obj)

targetOrigin是限定消息接受范围，不限制就用星号 *

接受信息的message事件

```
var onmessage = function(event) {
  var data = event.data;
  var origin = event.origin;
}

if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('message',onmessage,false);
}else if(typeof window.attachEvent != 'undefined'){
    window.attachEvent('onmessage', onmessage);
}
```



# 如何减少options请求？

Access-Control-Max-Age:1800

首部字段 Access-Control-Max-Age 表明该响应的有效时间，单位是【秒】，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。

不同浏览器有不同的上限。在Firefox中，上限是24h（即86400秒），而在Chromium 中则是10min（即600秒）。Chromium 同时规定了一个默认值 5 秒。

Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。也就是说，如果设置了10分钟的缓存，在10分钟内，所有请求第一次会产生options请求，第二次以及第二次以后就只发送真正的请求了。

Access-Control-Max-Age:-1时，将禁用options请求，需要对所有呼叫进行预检选项检查。
## React 16 之前的不足

首先我们了解一下 React 的工作过程，当我们通过render()和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：

- 调和阶段(Reconciler)：

React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。

- 渲染阶段(Renderer)：

遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。

在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 Stack Reconciler，主要是为了区别 Fiber Reconciler 取的一个名字。

这种方式有一个特点：一旦任务开始进行，就无法中断，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。



## Fiber reconciler 优化思路

Fiber reconciler 使用了scheduling(调度)这一过程， 每次只做一个很小的任务，做完后能够“喘口气儿”，

回到主线程看下有没有什么更高优先级的任务需要处理，如果有则先处理更高优先级的任务，没有则继续执行



`React Fiber`解决过去 `Reconciler`存在的问题的思路是把渲染/更新过程(递归diff)拆分成一系列小任务，每次检查树上的一小部分，做完看是否还有时间继续下一个任务，有的话继续，没有的话把自己挂起，主线程不忙的时候再继续。







## React Fiber

### 背景

- 大量的同步计算任务阻塞了浏览器UI渲染，默认情况下JS运算，页面布局，和页面绘制都是运行在浏览器的主线程中
- 假如JS元算持续占用主线程，页面就没办法得到及时的更新，使用setSate更新页面的时候，React会遍历所有的节点，与旧的dom节点惊醒diff算法对比，最小的代价更新页面，整个过程是不能被打断的，假如页面元素很多，整个过程的占用时间可能超过16毫秒，会出现掉帧的现象

### 解决思路

将运算切割为多个步骤，分批完成，在完成一部分任务后，将控制权交还给浏览器，让浏览器有时间对页面进行渲染 旧版的react通过递归的方式进行渲染，使用JS自身的函数调用栈，他会执行到栈空为止 Fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续、丢弃执行的任务，实现的方式就是使用了浏览器的requestldleCallback 这个API

### Fiber是一个执行单元

每次执行完一个执行单元，React就会检查还剩下多少时间，如果没有时间就把控制权让出去

## 任务拆分

Fiber拆分的单位是按照虚拟dom节点来拆，因为fiber tree是根据虚拟dom来构造出来的

## 任务暂停

Fiber利用浏览器的api`requestIdleCallback`来让浏览器空闲的时候执行某种任务

```
function fiber(剩余时间) {
 if (剩余时间 > 任务所需时间) {
 做任务;
 } else {
 requestIdleCallback(fiber);
 }
}
复制代码
```

使用`requestAnimationFrame`来渲染动画

## 优先级

```
{ 
 Synchronous: 1, // 同步任务，优先级最高
 Task: 2, // 当前调度正执行的任务
 Animation 3, // 动画
 High: 4, // 高优先级
 Low: 5, // 低优先级
 Offscreen: 6, // 当前屏幕外的更新，优先级最低
}
```


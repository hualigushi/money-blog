redux之所以这么复杂，是因为需要这些复杂的设计来限定在开发过程中开发者的行为。这些限定包括：

使用plain object和array来描述应用的状态
使用plain object描述系统中的变化
使用纯函数来描述处理变化的逻辑
而这些限定有什么好处呢？

将状态持久化到本地的存储中，然后开始运行，开箱即用
从服务器端提前初始化状态，并且把它发送到客户端，然后开始运行
序列化actions，同时可以捕获状态的快照，以及自动的bug上报，这些特点让错误复现以及debug都更加的容易

在redux中并不能做到一切都是确定的(side effect， async等等)，但是应该尽量去保证大多数部分都是确定的，这里包括：

视图的渲染是可确定的
状态的重建是可确定的
可确定性的重要之处在于：便于应用的测试，错误诊断和bug的修复。如果应用的视图和状态是不确定的，很难去确认当时的视图和状态是否有效，这样去定位错误就变得非常的困难。不过开头也说了，在redux中，不可能做到一切都是可确定的，例如：网络请求，存储，定时器这些边界效应是无法避免的，为了解决这些问题，我们可以进行隔离。借助一些中间件，可以将边界效应从状态管理中隔离出去。这个时候，代码会变得更加的简洁，逻辑也会更加的清晰，更重要的是，视图的渲染会抽象为状态机，从相同状态，经过一个确定的输入，能够得到一个确定的状态(输出)。也就是从state到view的流向始终应该是可确定，可预测的。

![](https://pic2.zhimg.com/80/v2-d207feb19e76baac3e5e9cc38e08b2e1_720w.jpg)

reducers应该是单一状态树： 把状态都存在一个地方有很多好处，便于管理，便于共享，因为在任何地方能够获取到完整的state；同时，在使用了Redux之后，应该尽量避免去使用local state
使用combineReducers去组合reducers：当应用变得庞大时，所有对状态的操作都放到同一个函数中，将变得难以维护。所以我们需要将reducers进行拆分不同的函数，然后使用combineReducers去组合成一个单一状态树，类似于上面的count和state。值得注意的是：上面的例子中，状态包括的是count和step，也就是说函数名就是状态名。
reducer必须是纯函数: 这点毋庸置疑，从最早接触到redux的时候，大家都应该知道需要保持reducer是纯函数，将原因也就是上面的第二大点。
提供一些默认值：以上面的count为例， 需要为state提供默认参数领，同时在switch语句中针对默认的action.type应该返回state。这样做的好处是：通过一些类型定义工具，例如Typescript和Flow，能够推断出state的值，在提示的时候会更加的智能。

## 含义

**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

```
function fn1() {
 var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
 var obj = {name:'hanzichi', age: 10};
 return obj;
}
var a = fn1();
var b = fn2();
```

首先声明了两个函数，分别叫做 fn1 和 fn2，当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象 	{name: 'hanzichi', age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被 JS 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放



## 标记清除

流程：

　　1.浏览器再运行的时候会给存储再内存中的所有变量都加上标记

　　2.去掉环境中的变量以及被环境中引用的变量的标记

　　3.如果还有变量有标记，就会被视为准备删除的变量

　　4.垃圾回收机制完成内存的清除工作，销毁那些带标记的变量，并回收他们所占用的内存空间



## 什么时候触发垃圾回收
一般浏览器会自动触发 GC，当触发 GC 的时候，浏览器就会停止工作。如果频繁触发 GC 页面就会发生抖动现象。

一般的 GC 耗时在 100ms 左右，对于一般的程序来说够了。但是对于一些流畅度要求高的程序来说就很麻烦，这就需要新引擎需要优化的地方。


## GC方案

#### 基础方案

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。

#### GC的缺陷

GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

#### GC优化策略

1. **分代回收**（Generation GC） V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：

![浏览器垃圾回收机制与 Vue 项目内存泄漏分析](http://p3.pstatp.com/large/pgc-image/3fe649e46a63419fbd17ef5b699b4ecb)



> 这里需要补充的是：对于 tenured generation 对象，有额外的开销：把它从 young generation 迁移到       tenured generation，另外，如果被引用了，那引用的指向也需要修改。

2. **增量GC** 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![浏览器垃圾回收机制与 Vue 项目内存泄漏分析](http://p3.pstatp.com/large/pgc-image/be21b45d125b40adb1bd3ebb4c40381f)



> 这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。



## chrome 的 GC 优化
V8 引擎的垃圾回收策略主要基于分代垃圾回收机制：

- 将整个堆内存分为新生代内存和老龄代内存，所有的内存分配操作发生在新生代

- 新生代内存又分成两部分，From（使用） 空间和 To（闲置） 空间，所有的内存分配操作发生在 From 空间

- 新生代空间发生 GC（复制算法）

  - From 空间中存活的对象复制到 To 空间，释放未存活的对象

  - 转换两者的角色 From 空间变为 To 空间，To 空间变为 From 空间

  - 如果某个对象已经经历过一次复制算法，就将该对象复制到老龄代空间

  - 如果 To 空间的使用率超过了 25%，将整个空间的对象复制到老龄代空间。主要是为了角色转换之后留足分配内存的空间

- 老龄代空间发生 GC （标记清除与标记合并）

  - 主要采用标记清除算法，通过标记清除算法清理未存活的对象
  - 清除算法完成之后会使内存空间出现不连续的状态，这种内存碎片会对后续的内存分配造成问题。因此在内存空间不足的时候采用标记合并算法，将活着的对象移动到内存的一端，完成之后清除另外一端的对象

- 新生代的 GC 触发要比老龄代的频繁

- 一般浏览器要求最高 60fps，算下来每帧 16.6ms。Chrome 为了缩短 GC 时间，它尝试将工作分摊到每个空闲时间。它将检查每个帧时间（16.6 ms）的剩余时间，并尝试为 GC 做一些工作

  - 如果垃圾收集事件可能很快发生，V8 GC 将检查每 n 个分配或 m 个时间单位。V8 GC 在任务调度程序中为事件注册空闲任务。
  - 任务调度程序将调度空闲任务并使用可用空闲时间调用给定的回调。V8 GC 将检查任务是否仍处于待处理状态，以及是否有足够的空闲时间来处理任务。

后来V8逐渐进化，GC的实现越来越复杂。目前的默认实现是new space还是用copying GC，而global GC则默认用incremental marking + lazy sweeping为主，mark-compact为备份。
为什么我们需要这个 api？
从微任务本身的概念来说的话，就是当我们期望某段代码，不阻塞当前执行的同步代码，同时又期望它尽可能快地执行时，我们就需要它（这里不再赘述微任务的概念，可以参考这篇文章）。

一般情况下，如果是编写业务代码，我觉的很少会遇到这样的需求，唯一能想到的情况可能存在于一些对即时反馈有性能要求的场景，比如搜索，当输入关键字后发送异步请求获取搜索信息之后，我们可能会在前端对搜索结果进行一些处理，比如排序或者分组，但是这些操作可能不是优先级最高的任务，但它们又比较耗时（比如排序），因此我们可能期望推迟它们的执行，但又期望它们尽可能早地执行。



```
queueMicrotask(() => {
    console.log('queueMicrotask');
});
```



# queueMicrotask 优势

1. 我们应当使用底层 api 来直接完成类似的功能，而非用顶层 api 进行模拟

2. 模拟过程中，对于异常情况，会造成一些困扰，比如 Promise.resolve 会将异常转化为一个 rejected的 Promise

3. 模拟过程中，会创建额外的对象（造成一定意义上的浪费），比如 Promise.resolve 会返回一个 Promise 实例对象，而直接 queueMicrotask 则不会

4. 除了微任务，其他类型的异步任务都有对应的 api 可供使用，比如宏任务、RAF

5. 继上一点的基础上，语义性会更好，同时帮助开发者理解这些不同异步任务之间的区别

​       setTimeout(callback, 0) - 宏任务

​       requestAnimationFrame(callback) - RAF

​       queueMicrotask(callback) - 微任务

​    

# 潜在问题
由于它是一个用于指派微任务的底层 api，我们很可能会在其中无限制地指派微任务到其队列之中，这样做的效果就是，浏览器的微任务队列始终处于非空状态，这将导致控制权始终无法交还给浏览器进行下一次事件循环，然后它就卡死了。

你可以执行下面的代码来体验这个现象：

```
function infiniteEnqueue(fn) {
    queueMicrotask(() => infiniteEnqueue(fn))
}

infiniteEnqueue(()=>{})
```

执行这段代码会使浏览器当前的 tab 卡死，请慎用，建议先打开浏览器提供的进程管理窗口以供强制关闭卡死窗口。

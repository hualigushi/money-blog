市面上大部分前端的书籍也好，文章也好，甚至框架官方文档也好，确实都没有解释清楚一个问题：**前端框架到底帮你解决了什么问题？**



- 是数据驱动问题吗？不是，数据驱动我们自己用手敲也能敲的很优雅。
- 是事件监听问题吗？也不是，事件监听用事件代理就可以写出很好的代码。
- 是所谓的“组件化开发”吗？更不是，组件化开发是思想，有没有框架，组件化都是必须的。



**那么前端框架到底解决了什么问题？**



框架其实就解决了一个问题——**使用声明式语法，描述组件对象的嵌套关系，并自动生成与dom对象的对应关系。**



自己敲过框架轮子的人一定明白我在说什么——你在自己写框架的时候，最难处理的不是数据驱动，observable库有的是，也不是事件监听，那玩意儿jquery已经做的很好了，更不是模板语法，谁还写不出个模板转render的函数？真正有点麻烦的问题是：

- dom对象以及他们的从属（同时是传递关系）关系，是通过html自动生成的，然而当你把“组件”抽象为js对象，你怎么能实现子组件的自动创建，自动销毁，自动数据传递，自动render，自动事件监听（不一定是dom事件）？
- 怎么把js组件对象存在它应该在的地方（我的标题图截得是preact源码解决这个问题的部分，preact的子组件实例，是存在dom节点上的），并且rerender的时候能把js组件对象和dom节点对应起来？
- 什么时候需要new，什么时候复用原来的组件？
- 组件重渲染之后，怎么commit到dom上？



这套机制，才是前端框架真正替你省力的“脏活”，因为不如此，你的组件根本集成不起来，“组件化开发”、“数据驱动”也就无从谈起。至于框架对外提供的那些特性和语法糖，其实都见仁见智，有人喜欢有人不喜欢。但是我前面说的那些脏活，才是一个框架之所以是一个框架的理由。



关于这套机制，类angular框架和类react框架分别讲了两个故事——

- angular讲的故事是“模板编译为能精细感知model变化事件的dom-commiter”。
- react讲的故事是“model怎么变不重要，我只要model当前状态，我有办法给你patch到dom上”。



表面上看起来是很不一样的，但是本质上都是做同一件事——

> 你在模板里面也好，jsx里面也好，使用组件时写的的都是组件的类型，然而实际render的时候，框架帮你自动创建了组件实例。第二次render的时候，框架又帮你做了两件事，第一件事是，帮你找到应被复用的组件实例，指挥他重新render一遍，第二件事是，帮你把render的结果commit到正确dom节点上。



所以“xxx框架比yyy框架如何”这种问题，压根就不是问题——反正他们干的都是同一件事情，内部实现的不同对你来说也不太重要，纠结什么框架好有什么用呢？反正在真正比较复杂的项目中，框架的角色无非就是个view层，玩不出什么花样来。工程上那个框架最合心意用哪个就好。
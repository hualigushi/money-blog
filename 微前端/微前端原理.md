[TOC]



## 1. 基本原理

微前端的概念借鉴自后端的微服务，主要是为了解决大型工程在变更、维护、扩展等方面的困难而提出的。

目前主流的微前端方案包括以下几个：

1. **iframe**
2. **基座模式**，主要基于路由分发，`qiankun`和`single-spa`就是基于这种模式
3. **组合式集成**，即单独构建组件，按需加载，类似npm包的形式
4. **EMP**，主要基于`Webpack5 Module Federation`
5. **Web Components**

严格来讲，这些方案都不算是完整的微前端解决方案，它们只是用于解决微前端中**运行时容器**的相关问题。

除了运行时容器，一套完整的微前端方案还需要解决**版本管理、质量管控、配置下发、线上监控、灰度发布、安全监测**等与工程和平台相关的问题，而这些问题中的大部分工作目前仍处于探索阶段。

![在这里插入图片描述](http://images.12345.okgoes.com/blog/images/2021/2/23/166028/20210222001907103.png)

**iframe**：是传统的微前端解决方案，基于iframe标签实现，技术难度低，隔离性和兼容性很好，但是性能和使用体验比较差，多用于集成第三方系统；

**基座模式**：主要基于路由分发，即由一个基座应用来监听路由，并按照路由规则来加载不同的应用，以实现应用间解耦；

**组合式集成**：把组件单独打包和发布，然后在构建或运行时组合；

**EMP**：基于`Webpack5 Module Federation`，一种去中心化的微前端实现方案，它不仅能很好地隔离应用，还可以轻松实现应用间的资源共享和通信；

**Web Components**：是官方提出的组件化方案，它通过对组件进行更高程度的封装，来实现微前端，但是目前兼容性不够好，尚未普及。

总的来说，iframe主要用于简单并且性能要求不高的第三方系统；组合式集成目前主要用于前端组件化，而不是微前端；**基座模式**、**EMP**和**Web Components**是目前主流的微前端方案。

本文我们主要对`qiankun`所基于的基座模式进行介绍。它的**主要思路是将一个大型应用拆分成若干个更小、更简单，可以独立开发、测试和部署的子应用**，然后由一个基座应用根据路由进行应用切换。

如果以前端组件的概念作类比，我们可以把每个被拆分出的子应用看作是一个**应用级组件**，每个应用级组件专门实现某个特定的业务功能（如商品管理、订单管理等）。这里实际上谈到了微前端拆分的原则：即以业务功能为基本单元。经过拆分后，整个系统的结构也发生了变化：
![在这里插入图片描述](http://images.12345.okgoes.com/blog/images/2021/2/23/163428/20210222143728755.png)

左侧是传统大型单页应用的前端架构，所有模块都在一个应用内，由应用本身负责路由管理，是**应用分发路由**的方式；而右侧是基座模式下的系统架构，各个子应用互不相关，单独运行在不同的服务上，由基座应用根据路由选择加载哪个应用到页面内，是**路由分发应用**的方式。这种方式使得各个模块的耦合性大大降低，而微前端需要解决的主要问题就是如何拆分和组织这些子应用。

为了让这些拆分出的子应用在一个单页面内协同工作，我们需要一个“管理者”应用，这就是我们上面说的基座应用，也叫主应用。基座应用一般是用户最终访问的应用，它会根据定义的规则，将不同的应用加载到页面内供用户使用。当然，这种架构下的每个子应用也具备单独访问的能力。

为了配合基座应用，子应用必须经过一些改造，向外暴露出相应的生命周期钩子，以便基座应用加载和卸载。实际上，一个典型的基于vue-router的Vue应用与这种架构存在着很大的相似性：
![在这里插入图片描述](http://images.12345.okgoes.com/blog/images/2021/2/23/196157/20210222144320456.png)

在典型的Vue应用中，各个组件当然都必须基于Vue编写；但是**在微前端架构中，各个子应用可以基于不同的技术框架**，这也是它最大的优势之一。这是因为各个子应用是独立编译和部署的，而基座应用是在运行时动态加载的子应用，由于在启动子应用时已经经历过编译阶段，所以基座应用加载的都是原生JavaScript代码，自然与子应用所用的技术框架无关（`qiankun`甚至能加载jQuery编写的页面）。

概念性地讲，在微前端架构中，**各个子应用将一些特定的业务功能封装在一个业务黑箱中**，只对外暴露少量生命周期方法；**基座应用根据路由地址变化，动态地加载对应的业务黑箱，并将其渲染到指定的占位DOM元素上**。与Vue应用一样，微前端也可以一次加载多个业务黑箱，这称为多实例模式（类似于vue-router的命名视图）。



## 2. 微前端的主要优势

1. 技术兼容性好，各个子应用可以基于不同的技术架构
2. 代码库更小、内聚性更强
3. 便于独立编译、测试和部署，可靠性更高
4. 耦合性更低，各个团队可以独立开发，互不干扰
5. 可维护性和扩展性更好，便于局部升级和增量升级

关于**技术兼容性**，由于在被基座应用加载前， 所有子应用已经编译成原生代码输出，所以基座应用可以加载各类技术栈编写的应用；由于拆分后应用体积明显变小，并且每个应用只实现一个业务模块，因此其**内聚性更强**；另外子应用本身也是完整的应用，所以它可以**独立编译、测试和部署**；关于**耦合性**，由于各个子应用只负责各自的业务模块，所以耦合性很低，非常便于独立开发；关于**可维护性和扩展性**，由于拆分出的应用都是完整的应用，因此专门升级某个功能模块就成为了可能，并且当需要增加模块时，只需要创建一个新应用，并修改基座应用的路由规则即可。

不过这种微前端方案仍然存在缺点：



## 3. 当前微前端方案的一些缺点

1. 子应用间的资源共享能力较差，使得项目总体积变大
2. 需要对现有代码进行改造（指的是未按照微前端形式编写的旧工程）

首先，子应用之间保持较高的独立性，反而使一些**公共资源不便于共享**。虽然大型第三方库可以通过externals的方式上传到cdn，但像一些工具函数，通用业务组件等则不易共享，这就使得项目整体体积反而变大。由于改造成本不高，**代码改造**通常算不上很严重的问题，但仍存在一定的代价。





一般来说，微前端需要解决的问题分为两大类：

1. **应用的加载与切换**
2. **应用的隔离与通信**

应用的加载与切换需要解决的问题包括：**路由问题、应用入口、应用加载**；应用的隔离与通信需要解决的问题包括：**js隔离、css样式隔离、应用间通信**。

`single-spa`很好地解决了**路由**和**应用入口**两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用`system.js`或原生`script`标签来实现）；

`qiankun`在此基础上封装了一个**应用加载**方案（即`import-html-entry`），并给出了**js隔离**、**css样式隔离**和**应用间通信**三个问题的解决方案，同时提供了**预加载功能**。

借助`single-spa`提供的能力，我们只能把不同的应用加载到一个页面内，但是很难保证这些应用不会互相干扰。而`qiankun`为我们解决了这些后顾之忧，使得它成为一个更加完整的微前端运行时容器。
![在这里插入图片描述](http://images.12345.okgoes.com/blog/images/2021/2/23/106372/20210219154623177.png)
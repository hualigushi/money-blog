[TOC]



# 介绍

沙箱模式(Sandbox Pattern),顾名思义沙箱模式是创建了一个"沙箱"，可以理解为创建了一个黑盒，我们不管在里面做什么都不会影响到外面。而在JavaScript中就意味着，在沙箱中的操作被限死在当前作用域，不会对其他模块和个人沙箱造成任何影响。



# JS中沙箱的使用场景

1、jsonp：解析服务器所返回的jsonp请求时，如果不信任jsonp中的数据，可以通过创建沙箱的方式来解析获取数据；（TSW中处理jsonp请求时，创建沙箱来处理和解析数据）；

2、执行第三方js：当你有必要执行第三方js的时候，而这份js文件又不一定可信的时候；

3、在线代码编辑器：相信大家都有使用过一些在线代码编辑器，而这些代码的执行，基本都会放置在沙箱中，防止对页面本身造成影响；（例如：https://codesandbox.io/s/new）

4、vue的服务端渲染：vue的服务端渲染实现中，通过创建沙箱执行前端的bundle文件；在调用createBundleRenderer方法时候，允许配置runInNewContext为true或false的形式，判断是否传入一个新创建的sandbox对象以供vm使用；

5、vue模板中表达式计算：vue模板中表达式的计算被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不能够在模板表达式中试图访问用户定义的全局变量。




 # 沙箱实现一：with + new Function

首先从最简陋的方法说起，假如你想要通过eval和function直接执行一段代码，这是不现实的，因为代码内部可以沿着作用域链往上找，篡改全局变量，这是我们不希望的，所以你需要让沙箱内的变量访问都在你的监控范围内；不过，你可以使用with API，在with的块级作用域下，变量访问会优先查找你传入的参数对象，之后再往上找，所以相当于你变相监控到了代码中的“变量访问”：

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994f686bee1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


接下里你要做的是，就是暴露可以被访问的变量`exposeObj`，以及阻断沙箱内的对外访问。通过es6提供的proxy特性，可以获取到对对象上的所有改写：

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994fc72ebaf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

通过设置has函数，可以监听到变量的访问，在上述代码中，仅暴露个别外部变量供代码访问，其余不存在的属性，都会直接抛出error。其实还存在get、set函数，但是如果get和set函数只能拦截到当前对象属性的操作，对外部变量属性的读写操作无法监听到，所以只能使用has函数了。接下来我们测试一下：

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994fc9ca8b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

看起来一切似乎没有什么问题，但是问题出在了传入的对象，当调用的是console.log(a.b)的时候，has方法是无法监听到对b属性的访问的，假设所执行的代码是不可信的，这时候，它只需要通过a.b.__proto__就可以访问到Object构造函数的原型对象，再对原型对象进行一些篡改，例如将toString就能影响到外部的代码逻辑的。

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994fce960b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


例如上面所展示的代码，通过访问原型链的方式，实现了沙箱逃逸，并且篡改了原型链上的toString方法，一旦外部的代码执行了toString方法，就可以实现xss攻击，注入第三方代码；由于在内部定义执行的函数代码逻辑，仍然会沿着作用于链查找，为了绕开作用域链的查找，笔者通过访问箭头函数的constructor的方式拿到了构造函数Function，这个时候，Funtion内所执行的xss代码，在执行的时候，便不会再沿着作用域链往上找，而是直接在全局作用域下执行，通过这样的方式，实现了沙箱逃逸以及xss攻击。

你可能会想，如果我切断原型链的访问，是否就杜绝了呢？的确，你可以通过Object.create(null)的方式，传入一个不含有原型链的对象，并且让暴露的对象只有一层，不传入嵌套的对象，但是，即使是基本类型值，数字或字符串，同样也可以通过__proto__查找到原型链，而且，即使不传入对象，你还可以通过下面这种方式绕过：

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994fcddb7a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


可见，new Function + with的这种沙箱方式，防君子不防小人，当然，你也可以通过对传入的code代码做代码分析或过滤？假如传入的代码不是按照的规定的数据格式（例如json），就直接抛出错误，阻止恶意代码注入，但这始终不是一种安全的做法。



# 沙箱实现二：借助iframe实现沙箱

在前端最常见的方法，还是利用iframe来构造一个沙箱

这种方式更为方便、简单、安全，也是目前比较通用的前端实现沙箱的方案，假如你要执行的代码不是自己写的代码，不是可信的数据源，那么务必要使用iframe沙箱。sandbox是h5的提出的一个新属性， 启用方式就是在iframe标签中使用sandbox属性:

![](https://user-gold-cdn.xitu.io/2019/9/27/16d70994fcc8932a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

但是这也会带来一些限制：

1. script脚本不能执行
2. 不能发送ajax请求
3. 不能使用本地存储，即localStorage,cookie等
4. 不能创建新的弹窗和window
5. 不能发送表单
6. 不能加载额外插件比如flash等

可以对这个iframe标签进行一些配置：

![img](https://user-gold-cdn.xitu.io/2019/9/27/16d70995215db9f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



接下里你只需要结合postMessage API，将你需要执行的代码，和需要暴露的数据传递过去，然后和你的iframe页面通信就行了。

1）不过你需要注意的是，在子页面中，要注意不要让执行代码访问到`contentWindow`对象，因为你需要调用`contentWindow`的`postMessageAPI`给父页面传递信息，假如恶意代码也获取到了`contentWindow`对象，相当于就拿到了父页面的控制权了，这个时候可大事不妙。

2）当你使用`postMessageAPI`的时候，由于sandbox的origin默认为null，需要设置`allow-same-origin`允许两个页面进行通信，意味着子页面内可以发起请求，这时候你需要防范好CSRF，允许了同域请求，不过好在，并没有携带上cookie。

3）当你调用`postMessageAPI`传递数据给子页面的时候，传输的数据对象本身已经通过结构化克隆算法复制，如果你还不了解结构化克隆算法可以查看这个。

简单的说，通过postMessageAPI传递的对象，已经由浏览器处理过了，原型链已经被切断，同时，传过去的对象也是复制好了的，占用的是不同的内存空间，两者互不影响，所以你不需要担心出现第一种沙箱做法中出现的问题。

 

# nodejs中的沙箱使用

nodejs中使用沙箱很简单，只需要利用原生的`vm`模块，便可以快速创建沙箱，同时指定上下文。

![img](https://user-gold-cdn.xitu.io/2019/9/27/16d7099521d94ce6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

`vm`中提供了`runInNewContext`、`runInThisContext`、`runInContext`三个方法，三者的用法有个别出入，比较常用的是`runInNewContext`和`runInContext`，可以传入参数指定好上下文对象。

但是vm是绝对安全的吗？不一定。

![img](https://user-gold-cdn.xitu.io/2019/9/27/16d70995254ad3b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 通过上面这段代码，我们可以通过vm，停止掉主进程nodejs，导致程序不能继续往下执行，这是我们不希望的，

解决方案是绑定好context上下文对象，同时，为了避免通过原型链逃逸（nodejs中的对象并没有像浏览器端一样进行结构化复制，导致原型链依然保留），所以我们需要切断原型链，同时对于传入的暴露对象，只提供基本类型值。

![img](https://user-gold-cdn.xitu.io/2019/9/27/16d7099529816785?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 让我们来看一下TSW中是怎么使用的：

![img](https://user-gold-cdn.xitu.io/2019/9/27/16d709952c7d3d84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 通过`runInNewContext`返回沙箱中的构造函数`Function`，同时传入切断原型链的空对象防止逃逸，之后再外部使用的时候，只需要调用返回的这个函数，和普通的`new Function`一样调用即可。

即使这样，我们也不能保证这是绝对的安全，毕竟可能还有潜在的沙箱漏洞呢？